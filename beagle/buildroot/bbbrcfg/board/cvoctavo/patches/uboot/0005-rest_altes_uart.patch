diff --color -rupN uboot-2019.04/arch/arm/dts/cv_kurz.dts uboot.b/arch/arm/dts/cv_kurz.dts
--- uboot-2019.04/arch/arm/dts/cv_kurz.dts	1970-01-01 01:00:00.000000000 +0100
+++ uboot.b/arch/arm/dts/cv_kurz.dts	2020-12-14 08:42:03.972825517 +0100
@@ -0,0 +1,1110 @@
+/* cv_kurz.dts */
+
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "am33xx.dtsi"
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	model = "TI AM335x EVM";
+	compatible = "cv,kurz", "ti,am33xx";
+
+	cpus {
+		cpu@0 {
+			cpu0-supply = <&vdd1_reg>;
+		};
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x80000000 0x10000000>; /* 256 MB */
+	};
+
+	chosen {
+		stdout-path = &uart0;
+	};
+
+	vbat: fixedregulator0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vbat";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-boot-on;
+	};
+
+	vmmc: fixedregulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vmmc";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+	};
+
+	vdd1_reg: regulator@0 {
+		regulator-compatible = "regulator-fixed";
+		regulator-name = "vdd_mpu";
+		regulator-min-microvolt = <1250000>;
+		regulator-max-microvolt = <1250000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+};
+
+/* von pin mux tool, erst einmal nur mmc0 (bzw. mmc1 bei anderer zaehlweise ;-)) und uart0: */
+
+&am33xx_pinmux {
+	mygpmc1_pins_default: mygpmc1_pins_default {
+		pinctrl-single,pins = <
+#if 0
+			AM33XX_IOPAD(0x86c, PIN_OUTPUT | MUX_MODE0) /* (V17) gpmc_a11.gpmc_a11 */
+			AM33XX_IOPAD(0x868, PIN_OUTPUT | MUX_MODE0) /* (T16) gpmc_a10.gpmc_a10 */
+			AM33XX_IOPAD(0x864, PIN_OUTPUT | MUX_MODE0) /* (U16) gpmc_a9.gpmc_a9 */
+			AM33XX_IOPAD(0x860, PIN_OUTPUT | MUX_MODE0) /* (V16) gpmc_a8.gpmc_a8 */
+			AM33XX_IOPAD(0x85c, PIN_OUTPUT | MUX_MODE0) /* (T15) gpmc_a7.gpmc_a7 */
+			AM33XX_IOPAD(0x858, PIN_OUTPUT | MUX_MODE0) /* (U15) gpmc_a6.gpmc_a6 */
+			AM33XX_IOPAD(0x854, PIN_OUTPUT | MUX_MODE0) /* (V15) gpmc_a5.gpmc_a5 */
+			AM33XX_IOPAD(0x850, PIN_OUTPUT | MUX_MODE0) /* (R14) gpmc_a4.gpmc_a4 */
+			AM33XX_IOPAD(0x84c, PIN_OUTPUT | MUX_MODE0) /* (T14) gpmc_a3.gpmc_a3 */
+			AM33XX_IOPAD(0x848, PIN_OUTPUT | MUX_MODE0) /* (U14) gpmc_a2.gpmc_a2 */
+			AM33XX_IOPAD(0x844, PIN_OUTPUT | MUX_MODE0) /* (V14) gpmc_a1.gpmc_a1 */
+			AM33XX_IOPAD(0x840, PIN_OUTPUT | MUX_MODE0) /* (R13) gpmc_a0.gpmc_a0 */
+			AM33XX_IOPAD(0x83c, PIN_INPUT_PULLUP | MUX_MODE0) /* (U13) gpmc_ad15.gpmc_ad15 */
+			AM33XX_IOPAD(0x838, PIN_INPUT_PULLUP | MUX_MODE0) /* (V13) gpmc_ad14.gpmc_ad14 */
+			AM33XX_IOPAD(0x834, PIN_INPUT_PULLUP | MUX_MODE0) /* (R12) gpmc_ad13.gpmc_ad13 */
+			AM33XX_IOPAD(0x830, PIN_INPUT_PULLUP | MUX_MODE0) /* (T12) gpmc_ad12.gpmc_ad12 */
+			AM33XX_IOPAD(0x82c, PIN_INPUT_PULLUP | MUX_MODE0) /* (U12) gpmc_ad11.gpmc_ad11 */
+			AM33XX_IOPAD(0x828, PIN_INPUT_PULLUP | MUX_MODE0) /* (T11) gpmc_ad10.gpmc_ad10 */
+			AM33XX_IOPAD(0x824, PIN_INPUT_PULLUP | MUX_MODE0) /* (T10) gpmc_ad9.gpmc_ad9 */
+			AM33XX_IOPAD(0x820, PIN_INPUT_PULLUP | MUX_MODE0) /* (U10) gpmc_ad8.gpmc_ad8 */
+			AM33XX_IOPAD(0x81c, PIN_INPUT_PULLUP | MUX_MODE0) /* (T9) gpmc_ad7.gpmc_ad7 */
+			AM33XX_IOPAD(0x818, PIN_INPUT_PULLUP | MUX_MODE0) /* (R9) gpmc_ad6.gpmc_ad6 */
+			AM33XX_IOPAD(0x814, PIN_INPUT_PULLUP | MUX_MODE0) /* (V8) gpmc_ad5.gpmc_ad5 */
+			AM33XX_IOPAD(0x810, PIN_INPUT_PULLUP | MUX_MODE0) /* (U8) gpmc_ad4.gpmc_ad4 */
+			AM33XX_IOPAD(0x80c, PIN_INPUT_PULLUP | MUX_MODE0) /* (T8) gpmc_ad3.gpmc_ad3 */
+			AM33XX_IOPAD(0x808, PIN_INPUT_PULLUP | MUX_MODE0) /* (R8) gpmc_ad2.gpmc_ad2 */
+			AM33XX_IOPAD(0x804, PIN_INPUT_PULLUP | MUX_MODE0) /* (V7) gpmc_ad1.gpmc_ad1 */
+			AM33XX_IOPAD(0x800, PIN_INPUT_PULLUP | MUX_MODE0) /* (U7) gpmc_ad0.gpmc_ad0 */
+			AM33XX_IOPAD(0x87c, PIN_OUTPUT_PULLUP | MUX_MODE0) /* (V6) gpmc_csn0.gpmc_csn0 */
+			AM33XX_IOPAD(0x880, PIN_OUTPUT_PULLUP | MUX_MODE0) /* (U9) gpmc_csn1.gpmc_csn1 */
+			AM33XX_IOPAD(0x888, PIN_OUTPUT_PULLUP | MUX_MODE0) /* (T13) gpmc_csn3.gpmc_csn3 */
+			AM33XX_IOPAD(0x88c, PIN_INPUT_PULLUP | MUX_MODE0) /* (V12) gpmc_clk.gpmc_clk */
+			AM33XX_IOPAD(0x890, PIN_OUTPUT | MUX_MODE0) /* (R7) gpmc_advn_ale.gpmc_advn_ale */
+			AM33XX_IOPAD(0x894, PIN_OUTPUT | MUX_MODE0) /* (T7) gpmc_oen_ren.gpmc_oen_ren */
+			AM33XX_IOPAD(0x898, PIN_OUTPUT | MUX_MODE0) /* (U6) gpmc_wen.gpmc_wen */
+#else
+            0x0 (PIN_INPUT_PULLUP | MUX_MODE0)  /* gpmc_ad0.gpmc_ad0 */
+            0x4 (PIN_INPUT_PULLUP | MUX_MODE0)  /* gpmc_ad1.gpmc_ad1 */
+            0x8 (PIN_INPUT_PULLUP | MUX_MODE0)  /* gpmc_ad2.gpmc_ad2 */
+            0xc (PIN_INPUT_PULLUP | MUX_MODE0)  /* gpmc_ad3.gpmc_ad3 */
+            0x10 (PIN_INPUT_PULLUP | MUX_MODE0) /* gpmc_ad4.gpmc_ad4 */
+            0x14 (PIN_INPUT_PULLUP | MUX_MODE0) /* gpmc_ad5.gpmc_ad5 */
+            0x18 (PIN_INPUT_PULLUP | MUX_MODE0) /* gpmc_ad6.gpmc_ad6 */
+            0x1c (PIN_INPUT_PULLUP | MUX_MODE0) /* gpmc_ad7.gpmc_ad7 */
+
+            0x20 (PIN_INPUT_PULLUP | MUX_MODE0) /* Pin 179 - U10 - GPMC_AD8 --- Modes: gpmc_ad8 | lcd_data23 | mmc1_dat0 | mmc2_dat4 | ehrpwm2A | pr1_mii_mt0_clk | - | gpio0_22 */
+            0x24 (PIN_INPUT_PULLUP | MUX_MODE0) /* Pin 180 - T10 - GPMC_AD9 --- Modes: gpmc_ad9 | lcd_data22 | mmc1_dat1 | mmc2_dat5 | ehrpwm2B | pr1_mii0_col | - | gpio0_23 */
+            0x28 (PIN_INPUT_PULLUP | MUX_MODE0) /* Pin 181 - T11 - GPMC_AD10 --- Modes: gpmc_ad10 | lcd_data21 | mmc1_dat2 | mmc2_dat6 | ehrpwm2_tripzone_input | pr1_mii0_txen | - | gpio0_26 */
+            0x2C (PIN_INPUT_PULLUP | MUX_MODE0) /* Pin 182 - U12 - GPMC_AD11 --- Modes: gpmc_ad11 | lcd_data20 | mmc1_dat3 | mmc2_dat7 | ehrpwm0_synco | pr1_mii0_txd3 | - | gpio0_27 */
+            0x30 (PIN_INPUT_PULLUP | MUX_MODE0) /* Pin 185 - T12 - GPMC_AD12 --- Modes: gpmc_ad12 | lcd_data19 | mmc1_dat4 | mmc2_dat0 | eQEP2A_in | pr1_mii0_txd2 | pr1_pru0_pru_r30_14 | gpio1_12 */
+            0x34 (PIN_INPUT_PULLUP | MUX_MODE0) /* Pin 186 - R12 - GPMC_AD13 --- Modes: gpmc_ad13 | lcd_data18 | mmc1_dat5 | mmc2_dat1 | eQEP2B_in | pr1_mii0_txd1 | pr1_pru0_pru_r30_15 | gpio1_13 */
+            0x38 (PIN_INPUT_PULLUP | MUX_MODE0) /* Pin 187 - V13 - GPMC_AD14 --- Modes: gpmc_ad14 | lcd_data17 | mmc1_dat6 | mmc2_dat2 | eQEP2_index | pr1_mii0_txd0 | pr1_pru0_pru_r31_14 | gpio1_14 */
+            0x3C (PIN_INPUT_PULLUP | MUX_MODE0) /* Pin 188 - U13 - GPMC_AD15 --- Modes: gpmc_ad15 | lcd_data16 | mmc1_dat7 | mmc2_dat3 | eQEP2_strobe | pr1_ecap0_ecap_capin_apwm_o | pr1_pru0_pru_r31_15 | gpio1_15 */
+            0x88 (PIN_OUTPUT | MUX_MODE0) /* Pin 177 - T13 - GPMC_CSn3 --- Modes: gpmc_csn3 | gpmc_a3 | rmii2_crs_dv | mmc2_cmd | pr1_mii0_crs | pr1_mdio_data | EMU4 | gpio2_0 */
+            
+            0x40 (PIN_OUTPUT | MUX_MODE0) /* Pin 139 - R13 - GPMC_A0 --- Modes: gpmc_a0 | gmii2_txen | rgmii2_tctl | rmii2_txen | gpmc_a16 | pr1_mii_mt1_clk | ehrpwm1_tripzone_input | gpio1_16 */
+            0x44 (PIN_OUTPUT | MUX_MODE0) /* Pin 149 - V14 - GPMC_A1 --- Modes: gpmc_a1 | gmii2_rxdv | rgmii2_rctl | mmc2_dat0 | gpmc_a17 | pr1_mii1_txd3 | ehrpwm0_synco | gpio1_17 */
+            0x48 (PIN_OUTPUT | MUX_MODE0) /* Pin 140 - U14 - GPMC_A2 --- Modes: gpmc_a2 | gmii2_txd3 | rgmii2_td3 | mmc2_dat1 | gpmc_a18 | pr1_mii1_txd2 | ehrpwm1A | gpio1_18 */
+            0x4C (PIN_OUTPUT | MUX_MODE0) /* Pin 143 - T14 - GPMC_A3 --- Modes: gpmc_a3 | gmii2_txd2 | rgmii2_td2 | mmc2_dat2 | gpmc_a19 | pr1_mii1_txd1 | ehrpwm1B | gpio1_19 */
+            0x50 (PIN_OUTPUT | MUX_MODE0) /* Pin 144 - R14 - GPMC_A4 --- Modes: gpmc_a4 | gmii2_txd1 | rgmii2_td1 | rmii2_txd1 | gpmc_a20 | pr1_mii1_txd0 | eQEP1A_in | gpio1_20 */
+            0x54 (PIN_OUTPUT | MUX_MODE0) /* Pin 145 - V15 - GPMC_A5 --- Modes: gpmc_a5 | gmii2_txd0 | rgmii2_td0 | rmii2_txd0 | gpmc_a21 | pr1_mii1_rxd3 | eQEP1B_in | gpio1_21 */
+            0x58 (PIN_OUTPUT | MUX_MODE0) /* Pin 146 - U15 - GPMC_A6 --- Modes: gpmc_a6 | gmii2_txclk | rgmii2_tclk | mmc2_dat4 | gpmc_a22 | pr1_mii1_rxd2 | eQEP1_index | gpio1_22 */
+            0x5C (PIN_OUTPUT | MUX_MODE0) /* Pin 154 - T15 - GPMC_A7 --- Modes: gpmc_a7 | gmii2_rxclk | rgmii2_rclk | mmc2_dat5 | gpmc_a23 | pr1_mii1_rxd1 | eQEP1_strobe | gpio1_23 */
+            0x60 (PIN_OUTPUT | MUX_MODE0) /* Pin 150 - V16 - GPMC_A8 --- Modes: gpmc_a8 | gmii2_rxd3 | rgmii2_rd3 | mmc2_dat6 | gpmc_a24 | pr1_mii1_rxd0 | mcasp0_aclkx | gpio1_24 */
+            0x64 (PIN_OUTPUT | MUX_MODE0) /* Pin 151 - U16 - GPMC_A9 --- Modes: gpmc_a9 | gmii2_rxd2 | rgmii2_rd2 | mmc2_dat7/rmii2_crs_dv | gpmc_a25 | pr1_mii_mr1_clk | mcasp0_fsx | gpio1_25 */
+            0x68 (PIN_OUTPUT | MUX_MODE0) /* Pin 152 - T16 - GPMC_A10 --- Modes: gpmc_a10 | gmii2_rxd1 | rgmii2_rd1 | rmii2_rxd1 | gpmc_a26 | pr1_mii1_rxdv | mcasp0_axr0 | gpio1_26 */
+            0x6C (PIN_OUTPUT | MUX_MODE0) /* Pin 153 - V17 - GPMC_A11 --- Modes: gpmc_a11 | gmii2_rxd0 | rgmii2_rd0 | rmii2_rxd0 | gpmc_a27 | pr1_mii1_rxer | mcasp0_axr1 | gpio1_27 */
+            
+            0x90 (PIN_OUTPUT | MUX_MODE0) /* Pin 158 - R7 - GPMC_ADVn_ALE --- Modes: gpmc_advn_ale | - | timer4 | - | - | - | - | gpio2_2 */
+            0x94 (PIN_OUTPUT | MUX_MODE0) /* Pin 161 - T7 - GPMC_OEn_REn --- Modes: gpmc_oen_ren | - | timer7 | - | - | - | - | gpio2_3 */
+            0x98 (PIN_OUTPUT | MUX_MODE0) /* Pin 162 - U6 - GPMC_WEn --- Modes: gpmc_wen | - | timer6 | - | - | - | - | gpio2_4 */
+            
+            0x8C (PIN_INPUT_PULLUP | MUX_MODE0) /* Pin 178 - V12 - GPMC_CLK --- Modes: gpmc_clk | lcd_memory_clk | gpmc_wait1 | mmc2_clk | pr1_mii1_crs | pr1_mdio_mdclk | mcasp0_fsr | gpio2_1 */
+            
+#endif
+          >;
+	};
+
+	mymmc1_pins_default: mymmc1_pins_default {
+		pinctrl-single,pins = <
+			AM33XX_IOPAD(0x900, PIN_INPUT_PULLUP | MUX_MODE0) /* (G17) mmc0_clk.mmc0_clk */
+			AM33XX_IOPAD(0x904, PIN_INPUT_PULLUP | MUX_MODE0) /* (G18) mmc0_cmd.mmc0_cmd */
+			AM33XX_IOPAD(0x8fc, PIN_INPUT_PULLUP | MUX_MODE0) /* (G16) mmc0_dat0.mmc0_dat0 */
+			AM33XX_IOPAD(0x8f8, PIN_INPUT_PULLUP | MUX_MODE0) /* (G15) mmc0_dat1.mmc0_dat1 */
+			AM33XX_IOPAD(0x8f4, PIN_INPUT_PULLUP | MUX_MODE0) /* (F18) mmc0_dat2.mmc0_dat2 */
+			AM33XX_IOPAD(0x8f0, PIN_INPUT_PULLUP | MUX_MODE0) /* (F17) mmc0_dat3.mmc0_dat3 */
+		>;
+	};
+
+	/* /\* Optional sleep pin settings. Must manually enter values in the below skeleton. *\/ */
+	/* mymmc1_pins_sleep: mymmc1_pins_sleep { */
+	/* 	pinctrl-single,pins = < */
+	/* 		AM33XX_IOPAD(0x900,  ) /\* (G17) mmc0_clk.mmc0_clk *\/ */
+	/* 		AM33XX_IOPAD(0x904,  ) /\* (G18) mmc0_cmd.mmc0_cmd *\/ */
+	/* 		AM33XX_IOPAD(0x8fc,  ) /\* (G16) mmc0_dat0.mmc0_dat0 *\/ */
+	/* 		AM33XX_IOPAD(0x8f8,  ) /\* (G15) mmc0_dat1.mmc0_dat1 *\/ */
+	/* 		AM33XX_IOPAD(0x8f4,  ) /\* (F18) mmc0_dat2.mmc0_dat2 *\/ */
+	/* 		AM33XX_IOPAD(0x8f0,  ) /\* (F17) mmc0_dat3.mmc0_dat3 *\/ */
+	/* 	>; */
+	/* }; */
+
+	myuart0_pins_default: myuart0_pins_default {
+		pinctrl-single,pins = <
+			AM33XX_IOPAD(0x970, PIN_INPUT | MUX_MODE0) /* (E15) uart0_rxd.uart0_rxd */
+			AM33XX_IOPAD(0x974, PIN_OUTPUT | MUX_MODE0) /* (E16) uart0_txd.uart0_txd */
+			AM33XX_IOPAD(0x968, PIN_INPUT | MUX_MODE0) /* (E18) uart0_ctsn.uart0_ctsn */
+			AM33XX_IOPAD(0x96c, PIN_OUTPUT | MUX_MODE0) /* (E17) uart0_rtsn.uart0_rtsn */
+		>;
+	};
+
+	/* /\* Optional sleep pin settings. Must manually enter values in the below skeleton. *\/ */
+	/* myuart0_pins_sleep: myuart0_pins_sleep { */
+	/* 	pinctrl-single,pins = < */
+	/* 		AM33XX_IOPAD(0x970,  ) /\* (E15) uart0_rxd.uart0_rxd *\/ */
+	/* 		AM33XX_IOPAD(0x974,  ) /\* (E16) uart0_txd.uart0_txd *\/ */
+	/* 		AM33XX_IOPAD(0x968,  ) /\* (E18) uart0_ctsn.uart0_ctsn *\/ */
+	/* 		AM33XX_IOPAD(0x96c,  ) /\* (E17) uart0_rtsn.uart0_rtsn *\/ */
+	/* 	>; */
+	/* }; */
+
+	cpsw_default: cpsw_default {
+		pinctrl-single,pins = <
+			/* Slave 1 PHY0 TLK105 */
+			0x118 (PIN_INPUT_PULLDOWN | MUX_MODE0) /* Pin 115 - J17 - MII1_RX_DV --- Modes: gmii1_rxdv | lcd_memory_clk | rgmii1_rctl | uart5_txd | mcasp1_aclkx | mmc2_dat0 | mcasp0_aclkr | gpio3_4 */
+            0x114 (PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* Pin 109 - J16 - MII1_TX_EN --- Modes: gmii1_txen | rmii1_txen | rgmii1_tctl | timer4 | mcasp1_axr0 | eQEP0_index | mmc2_cmd | gpio3_3 */
+            0x110 (PIN_INPUT_PULLDOWN | MUX_MODE0) /* Pin 108 - J15 - MII1_RX_ER --- Modes: gmii1_rxerr | rmii1_rxerr | spi1_d1 | I2C1_SCL | mcasp1_fsx | uart5_rtsn | uart2_txd | gpio3_2 */
+			0x11C (PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* Pin 110 - J18 - MII1_TXD3 --- Modes: gmii1_txd3 | dcan0_tx | rgmii1_td3 | uart4_rxd | mcasp1_fsx | mmc2_dat1 | mcasp0_fsr | gpio0_16 */
+			0x120 (PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* Pin 111 - K15 - MII1_TXD2 --- Modes: gmii1_txd2 | dcan0_rx | rgmii1_td2 | uart4_txd | mcasp1_axr0 | mmc2_dat2 | mcasp0_ahclkx | gpio0_17 */
+			0x124 (PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* Pin 112 - K16 - MII1_TXD1 --- Modes: gmii1_txd1 | rmii1_txd1 | rgmii1_td1 | mcasp1_fsr | mcasp1_axr1 | eQEP0A_in | mmc1_cmd | gpio0_21 */
+			0x128 (PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* Pin 113 - K17 - MII1_TXD0 --- Modes: gmii1_txd0 | rmii1_txd0 | rgmii1_td0 | mcasp1_axr2 | mcasp1_aclkr | eQEP0B_in | mmc1_clk | gpio0_28 */
+			0x12C (PIN_INPUT_PULLDOWN | MUX_MODE0) /* Pin 114 - K18 - MII1_TX_CLK --- Modes: gmii1_txclk | uart2_rxd | rgmii1_tclk | mmc0_dat7 | mmc1_dat0 | uart1_dcdn | mcasp0_aclkx | gpio3_9 */
+			0x130 (PIN_INPUT_PULLDOWN | MUX_MODE0) /* Pin 122 - L18 - MII1_RX_CLK --- Modes: gmii1_rxclk | uart2_txd | rgmii1_rclk | mmc0_dat6 | mmc1_dat1 | uart1_dsrn | mcasp0_fsx | gpio3_10 */
+            0x134 (PIN_INPUT_PULLDOWN | MUX_MODE0) /* Pin 116 - L17 - MII1_RXD3 --- Modes: gmii1_rxd3 | uart3_rxd | rgmii1_rd3 | mmc0_dat5 | mmc1_dat2 | uart1_dtrn | mcasp0_axr0 | gpio2_18 */
+            0x138 (PIN_INPUT_PULLDOWN | MUX_MODE0) /* Pin 119 - L16 - MII1_RXD2 --- Modes: gmii1_rxd2 | uart3_txd | rgmii1_rd2 | mmc0_dat4 | mmc1_dat3 | uart1_rin | mcasp0_axr1 | gpio2_19 */
+            0x13C (PIN_INPUT_PULLDOWN | MUX_MODE0) /* Pin 120 - L15 - MII1_RXD1 --- Modes: gmii1_rxd1 | rmii1_rxd1 | rgmii1_rd1 | mcasp1_axr3 | mcasp1_fsr | eQEP0_strobe | mmc2_clk | gpio2_20 */
+			0x140 (PIN_INPUT_PULLDOWN | MUX_MODE0) /* Pin 121 - M16 - MII1_RXD0 --- Modes: gmii1_rxd0 | rmii1_rxd0 | rgmii1_rd0 | mcasp1_ahclkx | mcasp1_ahclkr | mcasp1_aclkr | mcasp0_axr3 | gpio2_21 */
+			
+
+#if 0
+			/* Slave 2 PHY1 KSZ9031 */
+			0x40 (PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* gpmc_a0.rgmii2_tctl */
+			0x44 (PIN_INPUT_PULLDOWN | MUX_MODE2)  /* gpmc_a1.rgmii2_rctl */
+			0x48 (PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* gpmc_a2.rgmii2_td3 */
+			0x4C (PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* gpmc_a3.rgmii2_td2 */
+			0x50 (PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* gpmc_a4.rgmii2_td1 */
+			0x54 (PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* gpmc_a5.rgmii2_td0 */
+			0x58 (PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* gpmc_a6.rgmii2_tclk */
+			0x5C (PIN_INPUT_PULLDOWN | MUX_MODE2)  /* gpmc_a7.rgmii2_rclk */
+			0x60 (PIN_INPUT_PULLDOWN | MUX_MODE2)  /* gpmc_a8.rgmii2_rd3 */
+			0x64 (PIN_INPUT_PULLDOWN | MUX_MODE2)  /* gpmc_a9.rgmii2_rd2 */
+			0x68 (PIN_INPUT_PULLDOWN | MUX_MODE2)  /* gpmc_a10.rgmii2_rd1 */
+			0x6C (PIN_INPUT_PULLDOWN | MUX_MODE2)  /* gpmc_a11.rgmii2_rd0 */
+#endif
+		>;
+	};
+	davinci_mdio_default: davinci_mdio_default {
+		pinctrl-single,pins = <
+			/* MDIO */
+			0x148 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE0) /* Pin 123 - M17 - MDIO --- Modes: mdio_data | timer6 | uart5_rxd | uart3_ctsn | mmc0_sdcd | mmc1_cmd | mmc2_cmd | gpio0_0 */
+            0x14C (PIN_OUTPUT_PULLUP | MUX_MODE0) /* Pin 124 - M18 - MDC --- Modes: mdio_clk | timer5 | uart5_txd | uart3_rtsn | mmc0_sdwp | mmc1_clk | mmc2_clk | gpio0_1 */
+		>;
+	};
+
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&myuart0_pins_default>;
+
+	status = "okay";
+};
+
+
+&mmc1 {
+	status = "okay";
+	vmmc-supply = <&vmmc>;
+	bus-width = <4>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&mymmc1_pins_default>;
+#if 0
+	cd-gpios = <&gpio0 6 GPIO_ACTIVE_LOW>;
+#else
+	cd-gpios = <&gpio0 6 GPIO_ACTIVE_HIGH>; /* so von kurz */
+#endif
+};
+
+&elm {
+	status = "okay";
+};
+
+// siehe: /Documentation/devicetree/bindings/mtd/gpmc-nand.txt
+&gpmc {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mygpmc1_pins_default>;
+	/* ranges = < */
+	/* 0 0 0x08000000 0x20000000 /\* CS0: NAND *\/ */
+	/* /\* 1 0 0x17000000 0x1000 /\\* CS1: CF-Card *\\/ *\/ */
+	/*   3 0 0x28000000 0x02000000 /\* CS3: FPGA*\/ /\* TODO job-api anpassen auf neue fpga-adressbasis 0x28000000 statt bisher 0x18000000 *\/ */
+	/* >; */
+#if 0
+	ranges = <0 0 0x08000000 0x20000000>; /* CS0: NAND */
+#else
+	ranges = <0 0 0x08000000 0x1000000>; /* CS0: NAND */
+#endif
+	
+	#address-cells = <2>; 
+	#size-cells = <1>; 
+
+	nand@0,0 {
+		compatible = "ti,omap2-nand";
+		reg = <0 0 4>; /* CS0, offset 0 */
+		ti,nand-ecc-opt = "bch8";
+		ti,elm-id = <&elm>;
+ 		rb-gpios = <&gpmc 0 GPIO_ACTIVE_HIGH>; /* gpmc_wait0 */
+
+		nand-bus-width = <8>;
+		gpmc,device-width = <1>;
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <44>;
+		gpmc,cs-wr-off-ns = <44>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <34>;
+		gpmc,adv-wr-off-ns = <44>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <40>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <54>;
+		gpmc,access-ns = <64>;
+		gpmc,rd-cycle-ns = <82>;
+		gpmc,wr-cycle-ns = <82>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+		gpmc,wr-access-ns = <40>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+
+		// TODO begin neu
+		partitions {
+			compatible = "fixed-partitions";
+		// TODO end neu
+		/* MTD partition table */
+		/* All SPL-* partitions are sized to minimal length
+		* which can be independently programmable. For
+		* NAND flash this is equal to size of erase-block */
+		#address-cells = <1>;
+		#size-cells = <1>;
+		partition@0 {
+			label = "NAND.SPL";
+			reg = <0x00000000 0x00020000>;
+		};
+		partition@1 {
+			label = "NAND.SPL.backup1";
+			reg = <0x00020000 0x00020000>;
+		};
+		partition@2 {
+			label = "NAND.SPL.backup2";
+			reg = <0x00040000 0x00020000>;
+		};
+		partition@3 {
+			label = "NAND.SPL.backup3";
+			reg = <0x00060000 0x00020000>;
+		};
+		partition@4 {
+			label = "NAND.u-boot-spl-os";
+			reg = <0x00080000 0x00040000>;
+		};
+		partition@5 {
+			label = "NAND.u-boot";
+			reg = <0x000C0000 0x00100000>;
+		};
+		partition@6 {
+			label = "NAND.u-boot-env";
+			reg = <0x001C0000 0x00020000>;
+		};
+		partition@7 {
+			label = "NAND.u-boot-env.backup1";
+			reg = <0x001E0000 0x00020000>;
+		};
+		partition@8 {
+			label = "NAND.kernel";
+			reg = <0x00200000 0x00800000>;
+		};
+		partition@9 {
+			label = "NAND.kparams";
+			reg = <0x00a00000 0x00040000>;
+		};
+		partition@10 {
+			label = "NAND.rootfs1";
+			reg = <0x00A40000 0x4000000>;
+		};
+		partition@11 {
+			label = "NAND.rootfs2";
+			reg = <0x04a40000 0x4000000>;
+		};
+		partition@12 {
+			label = "NAND.data";
+			reg = <0x08a40000 0x175C0000>;
+		};
+		// TODO begin neu
+		}; // partitions
+		// TODO end neu 
+	};
+	
+	/* /\* nor@1,0 { *\/ */
+	/* /\* 	ti,elm-id = <&elm>;   *\/ */
+	/* /\* 	reg = <1 0 0x01000>; /\\*CSn1*\\/ *\/ */
+
+		
+	/* /\* 	/\\*gpmc,burst-write;*\\/ *\/ */
+	/* /\* 	/\\*gpmc,burst-read;*\\/ *\/ */
+	/* /\* 	/\\*gpmc,burst-wrap;*\\/ *\/ */
+		
+	/* /\* 	/\\* CONFIG 1 *\\/ *\/ */
+	/* /\* 	bank-width = <2>;           /\\* GPMC_CONFIG1_DEVICESIZE(1), d.h. 16 bit *\\/ *\/ */
+        /* /\*         /\\* Fuer Sync muss GPMC PIN PORTMUX auf Input *\\/ *\/ */
+	/* /\* 	/\\*gpmc,sync-read;*\\/             /\\* GPMC_CONFIG1_READTYPE_ASYNC *\\/ *\/ */
+	/* /\* 	/\\*gpmc,sync-write;*\\/            /\\* GPMC_CONFIG1_WRITETYPE_ASYNC *\\/   *\/ */
+	/* /\* 	gpmc,clk-activation-ns = <2>;   /\\* Bestimmt Start Clock Bussignalen (Verschiebung)*\\/ *\/ */
+	/* /\* 	gpmc,burst-length = <1>;        /\\* org 16 GPMC_CONFIG1_PAGE_LEN(2) *\\/ *\/ */
+	/* /\* 	gpmc,mux-add-data = <0>;        /\\* CONFIG1_n MUXADDDATA = 0 fuer non-multiplexed *\/ */
+	/* /\* 	gpmc,sync-clk-ps = <40000>;     /\\* Clk Divider GPMC ClockFrequenz*\\/ *\/ */
+
+	/* /\* 	/\\* CONFIG 2 *\\/       *\/ */
+	/* /\* 	gpmc,cs-on-ns = <10>;           /\\*10 ns *\\/ *\/ */
+	/* /\* 	gpmc,cs-rd-off-ns = <160>;      /\\*240 180 CS 1 Read  *\\/ *\/ */
+	/* /\* 	gpmc,cs-wr-off-ns = <160>;      /\\*240 180 CS 1 Write *\\/ *\/ */
+	/* /\* 	/\\* CONFIG3 *\\/ *\/ */
+	/* /\* 	gpmc,adv-on-ns = <20>;          /\\*  Adv 0 *\\/ *\/ */
+	/* /\* 	gpmc,adv-rd-off-ns = <60>;      /\\*120 80 Adv 1 Read Cycle*\\/ *\/ */
+	/* /\* 	gpmc,adv-wr-off-ns = <60>;      /\\*120 80 Adv 1 Write Cycle *\\/         *\/ */
+	/* /\* 	/\\* CONFIG4 *\\/ *\/ */
+	/* /\* 	gpmc,oe-on-ns = <80>;       /\\*120 90 Read 0 *\\/ *\/ */
+	/* /\* 	gpmc,oe-off-ns = <160>;     /\\*220 180 Read 1 *\\/ *\/ */
+	/* /\* 	gpmc,we-on-ns = <80>;       /\\*120 90 Write 0 *\/ */
+	/* /\* 	gpmc,we-off-ns = <160>;     /\\*220 180 Write 1 *\\/         *\/ */
+	/* /\* 	/\\* CONFIG 5 *\\/ *\/ */
+	/* /\* 	gpmc,page-burst-access-ns = <6>; /\\*  *\\/ *\/ */
+	/* /\* 	gpmc,access-ns = <140>;     /\\*200 150 data capture (read access) *\\/ *\/ */
+	/* /\* 	gpmc,rd-cycle-ns = <160>;   /\\*240 180 total read cycle time *\\/ *\/ */
+	/* /\* 	gpmc,wr-cycle-ns = <160>;   /\\*240 180 total write cycle time *\\/ *\/ */
+
+	/* /\* 	/\\* CONFIG 6 *\\/ *\/ */
+	/* /\* 	gpmc,cycle2cycle-delay-ns = <150>; /\\* 36 CONFIG6:11:8 = 4 *\\/ *\/ */
+	/* /\* 	gpmc,wr-data-mux-bus-ns = <80>; /\\*120 80 Time,first data is driven to bus*\\/ *\/ */
+	/* /\* 	gpmc,wr-access-ns = <180>;      /\\* 180 80 Burst Mode ? *\\/ *\/ */
+		
+	/* /\* 	/\\* CONFIG 7 *\\/ *\/ */
+	/* /\* 	/\\* gpmc,bus-turnaround-ns = <12>;  *\\/  /\\*  *\\/ *\/ */
+	/* /\* 	/\\* gpmc,cycle2cycle-samecsen;      *\\/  /\\* CONFIG6:7 = 1 *\\/ *\/ */
+	/* /\* 	/\\* gpmc,cycle2cycle-diffcsen;      *\\/  /\\*  *\\/ *\/ */
+		
+	/* /\* }; *\/ */
+
+	/* /\*********************************************************************************************** */
+	/* *********************************************************************************************** */
+	/* **                                                                                           ** */
+	/* ** ACHTUNG! Alle Namen beziehen sich auf den Treibersourcecode in:                           ** */
+	/* ** /home/buildroot/linux-3.14.43+gitAUTOINC+875c69b2c3-g875c69b/arch/arm/mach-omap2/gpmc.c   ** */
+	/* **                                                                                           ** */
+	/* *********************************************************************************************** */
+	/* ***********************************************************************************************\/ */
+	/* nor@3,0 { */
+	/* 	ti,elm-id = <&elm>;   */
+	/* 	reg = <3 0 0x02000000>; /\*original war: <3 0 0x010000>*\/ /\*CSn3*\/ */
+
+	/* 	gpmc,sync-read;             /\* GPMC_CONFIG1_READTYPE_ASYNC *\/ */
+	/* 	gpmc,sync-write;            /\* GPMC_CONFIG1_WRITETYPE_ASYNC *\/   */
+
+	/* 	/\* um das optimum rauszuholen, hier cs, adv, oe und we um halben clock versetzt, da fpga setup/hold times ausreichen *\/ */
+	/* 	gpmc,adv-extra-delay; /\* adv on und off 1/2 clock spaeter *\/ */
+	/* 	/\* Nein, sonst zu kurze setup zeit fuers fpga, dann kann der erste takt nicht genutzt werden um gleich z.b. einen fifo zu treiben... *\/ */
+	/* 	/\*gpmc,cs-extra-delay;*\/ /\* analog *\/ */
+	/* 	/\*gpmc,oe-extra-delay;*\/ /\* analog *\/  */
+	/* 	/\*gpmc,we-extra-delay;*\/ /\* analog *\/ */
+		
+		
+	/* 	/\* CONFIG 1 *\/ */
+	/* 	/\* Unklar ob bank-width zu verwenden wie angegeben in: https://www.kernel.org/doc/Documentation/devicetree/bindings/mtd/gpmc-nor.txt */
+	/* 	oder ob device-width wie in: http://lxr.free-electrons.com/source/Documentation/devicetree/bindings/bus/ti-gpmc.txt?v=3.14 *\/ */
+	/* 	bank-width = <2>;           /\* GPMC_CONFIG1_DEVICESIZE(1) *\/ */
+	/* 	gpmc,device-width = <2>; /\* 16 bit; TODO kontrollieren ob GPMC_CONFIG1_DEVICESIZE 1 wird *\/ */
+        /*         /\* Fuer Sync muss GPMC PIN PORTMUX auf Input *\/ */
+	/* 	gpmc,clk-activation-ns = <20>;   /\* synchrone Clock (doch nicht?) sofort starten *\/ */
+	/* 	/\* weggelassen entsprechend http://lxr.free-electrons.com/source/Documentation/devicetree/bindings/bus/ti-gpmc.txt?v=3.14 *\/ */
+	/* 	/\*gpmc,burst-length = <1>;*\/        /\* org 16 GPMC_CONFIG1_PAGE_LEN(2) *\/ */
+	/* 	gpmc,mux-add-data = <2>;        /\* 2 fuer address-data multiplexing mode *\/         */
+	/* 	gpmc,sync-clk-ps = <10000>;     /\* synchrone Clock fuer fpga alle 1 gpmc f_clocks *\/ */
+
+	/* 	/\* CONFIG 2 *\/ */
+	/* 	/\* entspricht CSONTIME *\/        */
+	/* 	gpmc,cs-on-ns = <0>;           /\* config 2 *\/ */
+	/* 	/\* entspricht CSRDOFFTIME *\/ */
+	/* 	gpmc,cs-rd-off-ns = <90>;      /\* config 2 *\/  */
+	/* 	/\* CS# de-assertion time from start cycle time for write accesses */
+	/* 	/\* entspricht CSWROFFTIME *\/ */
+	/* 	gpmc,cs-wr-off-ns = <70>;     /\* config 2 *\/ */
+	/* 	/\* CONFIG3 *\/ */
+	/* 	gpmc,adv-on-ns = <0>;          /\*  config 3 *\/ */
+	/* 	gpmc,adv-rd-off-ns = <30>;     /\*  config 3 *\/ */
+	/* 	/\* entspricht ADVWROFFTIME *\/ */
+	/* 	gpmc,adv-wr-off-ns = <30>;     /\*  config 3 *\/ */
+	/* 	/\* CONFIG4 *\/ */
+	/* 	gpmc,oe-on-ns = <30>;       /\* config 4 *\/ */
+	/* 	gpmc,oe-off-ns = <80>;      /\* config 4 *\/  */
+	/* 	gpmc,we-on-ns = <00>;       /\* config 4 *\/ */
+	/* 	gpmc,we-off-ns = <60>;      /\* config 4 *\/ */
+	/* 	/\* CONFIG 5 *\/ */
+	/* 	/\*gpmc,page-burst-access-ns = <6>;*\/ /\* config 5 - vorerst kein burst *\/ */
+	/* 	gpmc,access-ns = <70>;       /\* config 5 *\/ */
+	/* 	gpmc,rd-cycle-ns = <100>;    /\* config 5 *\/  */
+	/* 	gpmc,wr-cycle-ns = <80>;    /\* config 5 *\/ */
+
+	/* 	/\* CONFIG 6 *\/ */
+	/* 	gpmc,cycle2cycle-delay-ns = <50>; /\* jetzt noetig, da cs als asynchrones reset dient *\/ */
+	/* 	gpmc,wr-data-mux-bus-ns = <30>;  /\* wechsel von addr zu data da address/data muxing *\/ */
+		
+		
+	/* 	/\* CONFIG 7 *\/ */
+	/* 	/\* gpmc,bus-turnaround-ns = <10>; *\/    /\* config 7 *\/ */
+	/* 	gpmc,cycle2cycle-samecsen;         /\* config 7 siehe kommentar zu cycle2cycle-delay-ns *\/ */
+	/* 	gpmc,cycle2cycle-diffcsen;        /\* config 7 *\/ */
+		
+
+	/* }; */
+	
+};
+
+&usb {
+	status = "okay";
+};
+
+&usb_ctrl_mod {
+	status = "okay";
+};
+
+&usb0_phy {
+	status = "okay";
+};
+
+&usb0 {
+	status = "okay";
+};
+
+
+
+/* #if 0 /\* von am335x-evm.dts: *\/ */
+
+/* &am33xx_pinmux { */
+/* 	pinctrl-names = "default"; */
+/* 	pinctrl-0 = <&matrix_keypad_s0 &volume_keys_s0 &clkout2_pin>; */
+
+/* 	matrix_keypad_s0: matrix_keypad_s0 { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x854, PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/\* gpmc_a5.gpio1_21 *\/ */
+/* 			AM33XX_IOPAD(0x858, PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/\* gpmc_a6.gpio1_22 *\/ */
+/* 			AM33XX_IOPAD(0x864, PIN_INPUT_PULLDOWN | MUX_MODE7)	/\* gpmc_a9.gpio1_25 *\/ */
+/* 			AM33XX_IOPAD(0x868, PIN_INPUT_PULLDOWN | MUX_MODE7)	/\* gpmc_a10.gpio1_26 *\/ */
+/* 			AM33XX_IOPAD(0x86c, PIN_INPUT_PULLDOWN | MUX_MODE7)	/\* gpmc_a11.gpio1_27 *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	volume_keys_s0: volume_keys_s0 { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x950, PIN_INPUT_PULLDOWN | MUX_MODE7)	/\* spi0_sclk.gpio0_2 *\/ */
+/* 			AM33XX_IOPAD(0x954, PIN_INPUT_PULLDOWN | MUX_MODE7)	/\* spi0_d0.gpio0_3 *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	i2c0_pins: pinmux_i2c0_pins { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x988, PIN_INPUT_PULLUP | MUX_MODE0)	/\* i2c0_sda.i2c0_sda *\/ */
+/* 			AM33XX_IOPAD(0x98c, PIN_INPUT_PULLUP | MUX_MODE0)	/\* i2c0_scl.i2c0_scl *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	i2c1_pins: pinmux_i2c1_pins { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x958, PIN_INPUT_PULLUP | MUX_MODE2)	/\* spi0_d1.i2c1_sda *\/ */
+/* 			AM33XX_IOPAD(0x95c, PIN_INPUT_PULLUP | MUX_MODE2)	/\* spi0_cs0.i2c1_scl *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	uart0_pins: pinmux_uart0_pins { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x970, PIN_INPUT_PULLUP | MUX_MODE0)	/\* uart0_rxd.uart0_rxd *\/ */
+/* 			AM33XX_IOPAD(0x974, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/\* uart0_txd.uart0_txd *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	uart1_pins: pinmux_uart1_pins { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x978, PIN_INPUT | MUX_MODE0)		/\* uart1_ctsn.uart1_ctsn *\/ */
+/* 			AM33XX_IOPAD(0x97C, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/\* uart1_rtsn.uart1_rtsn *\/ */
+/* 			AM33XX_IOPAD(0x980, PIN_INPUT_PULLUP | MUX_MODE0)	/\* uart1_rxd.uart1_rxd *\/ */
+/* 			AM33XX_IOPAD(0x984, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/\* uart1_txd.uart1_txd *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	clkout2_pin: pinmux_clkout2_pin { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x9b4, PIN_OUTPUT_PULLDOWN | MUX_MODE3)	/\* xdma_event_intr1.clkout2 *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	nandflash_pins_s0: nandflash_pins_s0 { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x800, PIN_INPUT_PULLUP | MUX_MODE0)	/\* gpmc_ad0.gpmc_ad0 *\/ */
+/* 			AM33XX_IOPAD(0x804, PIN_INPUT_PULLUP | MUX_MODE0)	/\* gpmc_ad1.gpmc_ad1 *\/ */
+/* 			AM33XX_IOPAD(0x808, PIN_INPUT_PULLUP | MUX_MODE0)	/\* gpmc_ad2.gpmc_ad2 *\/ */
+/* 			AM33XX_IOPAD(0x80c, PIN_INPUT_PULLUP | MUX_MODE0)	/\* gpmc_ad3.gpmc_ad3 *\/ */
+/* 			AM33XX_IOPAD(0x810, PIN_INPUT_PULLUP | MUX_MODE0)	/\* gpmc_ad4.gpmc_ad4 *\/ */
+/* 			AM33XX_IOPAD(0x814, PIN_INPUT_PULLUP | MUX_MODE0)	/\* gpmc_ad5.gpmc_ad5 *\/ */
+/* 			AM33XX_IOPAD(0x818, PIN_INPUT_PULLUP | MUX_MODE0)	/\* gpmc_ad6.gpmc_ad6 *\/ */
+/* 			AM33XX_IOPAD(0x81c, PIN_INPUT_PULLUP | MUX_MODE0)	/\* gpmc_ad7.gpmc_ad7 *\/ */
+/* 			AM33XX_IOPAD(0x870, PIN_INPUT_PULLUP | MUX_MODE0)	/\* gpmc_wait0.gpmc_wait0 *\/ */
+/* 			AM33XX_IOPAD(0x874, PIN_INPUT_PULLUP | MUX_MODE7)	/\* gpmc_wpn.gpio0_30 *\/ */
+/* 			AM33XX_IOPAD(0x87c, PIN_OUTPUT | MUX_MODE0)		/\* gpmc_csn0.gpmc_csn0  *\/ */
+/* 			AM33XX_IOPAD(0x890, PIN_OUTPUT | MUX_MODE0)		/\* gpmc_advn_ale.gpmc_advn_ale *\/ */
+/* 			AM33XX_IOPAD(0x894, PIN_OUTPUT | MUX_MODE0)		/\* gpmc_oen_ren.gpmc_oen_ren *\/ */
+/* 			AM33XX_IOPAD(0x898, PIN_OUTPUT | MUX_MODE0)		/\* gpmc_wen.gpmc_wen *\/ */
+/* 			AM33XX_IOPAD(0x89c, PIN_OUTPUT | MUX_MODE0)		/\* gpmc_be0n_cle.gpmc_be0n_cle *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	ecap0_pins: backlight_pins { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x964, MUX_MODE0)	/\* eCAP0_in_PWM0_out.eCAP0_in_PWM0_out *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	cpsw_default: cpsw_default { */
+/* 		pinctrl-single,pins = < */
+/* 			/\* Slave 1 *\/ */
+/* 			AM33XX_IOPAD(0x914, PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/\* mii1_txen.rgmii1_tctl *\/ */
+/* 			AM33XX_IOPAD(0x918, PIN_INPUT_PULLDOWN | MUX_MODE2)	/\* mii1_rxdv.rgmii1_rctl *\/ */
+/* 			AM33XX_IOPAD(0x91c, PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/\* mii1_txd3.rgmii1_td3 *\/ */
+/* 			AM33XX_IOPAD(0x920, PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/\* mii1_txd2.rgmii1_td2 *\/ */
+/* 			AM33XX_IOPAD(0x924, PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/\* mii1_txd1.rgmii1_td1 *\/ */
+/* 			AM33XX_IOPAD(0x928, PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/\* mii1_txd0.rgmii1_td0 *\/ */
+/* 			AM33XX_IOPAD(0x92c, PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/\* mii1_txclk.rgmii1_tclk *\/ */
+/* 			AM33XX_IOPAD(0x930, PIN_INPUT_PULLDOWN | MUX_MODE2)	/\* mii1_rxclk.rgmii1_rclk *\/ */
+/* 			AM33XX_IOPAD(0x934, PIN_INPUT_PULLDOWN | MUX_MODE2)	/\* mii1_rxd3.rgmii1_rd3 *\/ */
+/* 			AM33XX_IOPAD(0x938, PIN_INPUT_PULLDOWN | MUX_MODE2)	/\* mii1_rxd2.rgmii1_rd2 *\/ */
+/* 			AM33XX_IOPAD(0x93c, PIN_INPUT_PULLDOWN | MUX_MODE2)	/\* mii1_rxd1.rgmii1_rd1 *\/ */
+/* 			AM33XX_IOPAD(0x940, PIN_INPUT_PULLDOWN | MUX_MODE2)	/\* mii1_rxd0.rgmii1_rd0 *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	cpsw_sleep: cpsw_sleep { */
+/* 		pinctrl-single,pins = < */
+/* 			/\* Slave 1 reset value *\/ */
+/* 			AM33XX_IOPAD(0x914, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x918, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x91c, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x920, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x924, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x928, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x92c, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x930, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x934, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x938, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x93c, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x940, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 		>; */
+/* 	}; */
+
+/* 	davinci_mdio_default: davinci_mdio_default { */
+/* 		pinctrl-single,pins = < */
+/* 			/\* MDIO *\/ */
+/* 			AM33XX_IOPAD(0x948, PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE0)	/\* mdio_data.mdio_data *\/ */
+/* 			AM33XX_IOPAD(0x94c, PIN_OUTPUT_PULLUP | MUX_MODE0)			/\* mdio_clk.mdio_clk *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	davinci_mdio_sleep: davinci_mdio_sleep { */
+/* 		pinctrl-single,pins = < */
+/* 			/\* MDIO reset value *\/ */
+/* 			AM33XX_IOPAD(0x948, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x94c, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 		>; */
+/* 	}; */
+
+/* 	mmc1_pins: pinmux_mmc1_pins { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x960, PIN_INPUT | MUX_MODE7)		/\* spi0_cs1.gpio0_6 *\/ */
+/* 			AM33XX_IOPAD(0x8fc, PIN_INPUT_PULLUP | MUX_MODE0)	/\* mmc0_dat0.mmc0_dat0 *\/ */
+/* 			AM33XX_IOPAD(0x8f8, PIN_INPUT_PULLUP | MUX_MODE0)	/\* mmc0_dat1.mmc0_dat1 *\/ */
+/* 			AM33XX_IOPAD(0x8f4, PIN_INPUT_PULLUP | MUX_MODE0)	/\* mmc0_dat2.mmc0_dat2 *\/ */
+/* 			AM33XX_IOPAD(0x8f0, PIN_INPUT_PULLUP | MUX_MODE0)	/\* mmc0_dat3.mmc0_dat3 *\/ */
+/* 			AM33XX_IOPAD(0x904, PIN_INPUT_PULLUP | MUX_MODE0)	/\* mmc0_cmd.mmc0_cmd *\/ */
+/* 			AM33XX_IOPAD(0x900, PIN_INPUT_PULLUP | MUX_MODE0)	/\* mmc0_clk.mmc0_clk *\/ */
+/* 			AM33XX_IOPAD(0x9a0, PIN_INPUT | MUX_MODE4)		/\* mcasp0_aclkr.mmc0_sdwp *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	mmc3_pins: pinmux_mmc3_pins { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x844, PIN_INPUT_PULLUP | MUX_MODE3)	/\* gpmc_a1.mmc2_dat0, INPUT_PULLUP | MODE3 *\/ */
+/* 			AM33XX_IOPAD(0x848, PIN_INPUT_PULLUP | MUX_MODE3)	/\* gpmc_a2.mmc2_dat1, INPUT_PULLUP | MODE3 *\/ */
+/* 			AM33XX_IOPAD(0x84c, PIN_INPUT_PULLUP | MUX_MODE3)	/\* gpmc_a3.mmc2_dat2, INPUT_PULLUP | MODE3 *\/ */
+/* 			AM33XX_IOPAD(0x878, PIN_INPUT_PULLUP | MUX_MODE3)	/\* gpmc_ben1.mmc2_dat3, INPUT_PULLUP | MODE3 *\/ */
+/* 			AM33XX_IOPAD(0x888, PIN_INPUT_PULLUP | MUX_MODE3)	/\* gpmc_csn3.mmc2_cmd, INPUT_PULLUP | MODE3 *\/ */
+/* 			AM33XX_IOPAD(0x88c, PIN_INPUT_PULLUP | MUX_MODE3)	/\* gpmc_clk.mmc2_clk, INPUT_PULLUP | MODE3 *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	wlan_pins: pinmux_wlan_pins { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x840, PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/\* gpmc_a0.gpio1_16 *\/ */
+/* 			AM33XX_IOPAD(0x99c, PIN_INPUT | MUX_MODE7)		/\* mcasp0_ahclkr.gpio3_17 *\/ */
+/* 			AM33XX_IOPAD(0x9ac, PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/\* mcasp0_ahclkx.gpio3_21 *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	lcd_pins_s0: lcd_pins_s0 { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x820, PIN_OUTPUT | MUX_MODE1)		/\* gpmc_ad8.lcd_data23 *\/ */
+/* 			AM33XX_IOPAD(0x824, PIN_OUTPUT | MUX_MODE1)		/\* gpmc_ad9.lcd_data22 *\/ */
+/* 			AM33XX_IOPAD(0x828, PIN_OUTPUT | MUX_MODE1)		/\* gpmc_ad10.lcd_data21 *\/ */
+/* 			AM33XX_IOPAD(0x82c, PIN_OUTPUT | MUX_MODE1)		/\* gpmc_ad11.lcd_data20 *\/ */
+/* 			AM33XX_IOPAD(0x830, PIN_OUTPUT | MUX_MODE1)		/\* gpmc_ad12.lcd_data19 *\/ */
+/* 			AM33XX_IOPAD(0x834, PIN_OUTPUT | MUX_MODE1)		/\* gpmc_ad13.lcd_data18 *\/ */
+/* 			AM33XX_IOPAD(0x838, PIN_OUTPUT | MUX_MODE1)		/\* gpmc_ad14.lcd_data17 *\/ */
+/* 			AM33XX_IOPAD(0x83c, PIN_OUTPUT | MUX_MODE1)		/\* gpmc_ad15.lcd_data16 *\/ */
+/* 			AM33XX_IOPAD(0x8a0, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data0.lcd_data0 *\/ */
+/* 			AM33XX_IOPAD(0x8a4, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data1.lcd_data1 *\/ */
+/* 			AM33XX_IOPAD(0x8a8, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data2.lcd_data2 *\/ */
+/* 			AM33XX_IOPAD(0x8ac, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data3.lcd_data3 *\/ */
+/* 			AM33XX_IOPAD(0x8b0, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data4.lcd_data4 *\/ */
+/* 			AM33XX_IOPAD(0x8b4, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data5.lcd_data5 *\/ */
+/* 			AM33XX_IOPAD(0x8b8, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data6.lcd_data6 *\/ */
+/* 			AM33XX_IOPAD(0x8bc, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data7.lcd_data7 *\/ */
+/* 			AM33XX_IOPAD(0x8c0, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data8.lcd_data8 *\/ */
+/* 			AM33XX_IOPAD(0x8c4, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data9.lcd_data9 *\/ */
+/* 			AM33XX_IOPAD(0x8c8, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data10.lcd_data10 *\/ */
+/* 			AM33XX_IOPAD(0x8cc, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data11.lcd_data11 *\/ */
+/* 			AM33XX_IOPAD(0x8d0, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data12.lcd_data12 *\/ */
+/* 			AM33XX_IOPAD(0x8d4, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data13.lcd_data13 *\/ */
+/* 			AM33XX_IOPAD(0x8d8, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data14.lcd_data14 *\/ */
+/* 			AM33XX_IOPAD(0x8dc, PIN_OUTPUT | MUX_MODE0)		/\* lcd_data15.lcd_data15 *\/ */
+/* 			AM33XX_IOPAD(0x8e0, PIN_OUTPUT | MUX_MODE0)		/\* lcd_vsync.lcd_vsync *\/ */
+/* 			AM33XX_IOPAD(0x8e4, PIN_OUTPUT | MUX_MODE0)		/\* lcd_hsync.lcd_hsync *\/ */
+/* 			AM33XX_IOPAD(0x8e8, PIN_OUTPUT | MUX_MODE0)		/\* lcd_pclk.lcd_pclk *\/ */
+/* 			AM33XX_IOPAD(0x8ec, PIN_OUTPUT | MUX_MODE0)		/\* lcd_ac_bias_en.lcd_ac_bias_en *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	mcasp1_pins: mcasp1_pins { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x90c, PIN_INPUT_PULLDOWN | MUX_MODE4) /\* mii1_crs.mcasp1_aclkx *\/ */
+/* 			AM33XX_IOPAD(0x910, PIN_INPUT_PULLDOWN | MUX_MODE4) /\* mii1_rxerr.mcasp1_fsx *\/ */
+/* 			AM33XX_IOPAD(0x908, PIN_OUTPUT_PULLDOWN | MUX_MODE4) /\* mii1_col.mcasp1_axr2 *\/ */
+/* 			AM33XX_IOPAD(0x944, PIN_INPUT_PULLDOWN | MUX_MODE4) /\* rmii1_ref_clk.mcasp1_axr3 *\/ */
+/* 		>; */
+/* 	}; */
+
+/* 	mcasp1_pins_sleep: mcasp1_pins_sleep { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x90c, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x910, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x908, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 			AM33XX_IOPAD(0x944, PIN_INPUT_PULLDOWN | MUX_MODE7) */
+/* 		>; */
+/* 	}; */
+
+/* 	dcan1_pins_default: dcan1_pins_default { */
+/* 		pinctrl-single,pins = < */
+/* 			AM33XX_IOPAD(0x968, PIN_OUTPUT | MUX_MODE2) /\* uart0_ctsn.d_can1_tx *\/ */
+/* 			AM33XX_IOPAD(0x96c, PIN_INPUT_PULLDOWN | MUX_MODE2) /\* uart0_rtsn.d_can1_rx *\/ */
+/* 		>; */
+/* 	}; */
+/* }; */
+/* #endif */
+/* #if 0 */
+
+/* &uart1 { */
+/* 	pinctrl-names = "default"; */
+/* 	pinctrl-0 = <&uart1_pins>; */
+
+/* 	status = "okay"; */
+/* }; */
+
+/* &i2c0 { */
+/* 	pinctrl-names = "default"; */
+/* 	pinctrl-0 = <&i2c0_pins>; */
+
+/* 	status = "okay"; */
+/* 	clock-frequency = <400000>; */
+
+/* 	tps: tps@2d { */
+/* 		reg = <0x2d>; */
+/* 	}; */
+/* }; */
+
+/* &usb { */
+/* 	status = "okay"; */
+/* }; */
+
+/* &usb_ctrl_mod { */
+/* 	status = "okay"; */
+/* }; */
+
+/* &usb0_phy { */
+/* 	status = "okay"; */
+/* }; */
+
+/* &usb1_phy { */
+/* 	status = "okay"; */
+/* }; */
+
+/* &usb0 { */
+/* 	status = "okay"; */
+/* }; */
+
+/* &usb1 { */
+/* 	status = "okay"; */
+/* 	dr_mode = "host"; */
+/* }; */
+
+/* &cppi41dma  { */
+/* 	status = "okay"; */
+/* }; */
+
+/* &i2c1 { */
+/* 	pinctrl-names = "default"; */
+/* 	pinctrl-0 = <&i2c1_pins>; */
+
+/* 	status = "okay"; */
+/* 	clock-frequency = <100000>; */
+
+/* 	lis331dlh: lis331dlh@18 { */
+/* 		compatible = "st,lis331dlh", "st,lis3lv02d"; */
+/* 		reg = <0x18>; */
+/* 		Vdd-supply = <&lis3_reg>; */
+/* 		Vdd_IO-supply = <&lis3_reg>; */
+
+/* 		st,click-single-x; */
+/* 		st,click-single-y; */
+/* 		st,click-single-z; */
+/* 		st,click-thresh-x = <10>; */
+/* 		st,click-thresh-y = <10>; */
+/* 		st,click-thresh-z = <10>; */
+/* 		st,irq1-click; */
+/* 		st,irq2-click; */
+/* 		st,wakeup-x-lo; */
+/* 		st,wakeup-x-hi; */
+/* 		st,wakeup-y-lo; */
+/* 		st,wakeup-y-hi; */
+/* 		st,wakeup-z-lo; */
+/* 		st,wakeup-z-hi; */
+/* 		st,min-limit-x = <120>; */
+/* 		st,min-limit-y = <120>; */
+/* 		st,min-limit-z = <140>; */
+/* 		st,max-limit-x = <550>; */
+/* 		st,max-limit-y = <550>; */
+/* 		st,max-limit-z = <750>; */
+/* 	}; */
+
+/* 	tsl2550: tsl2550@39 { */
+/* 		compatible = "taos,tsl2550"; */
+/* 		reg = <0x39>; */
+/* 	}; */
+
+/* 	tmp275: tmp275@48 { */
+/* 		compatible = "ti,tmp275"; */
+/* 		reg = <0x48>; */
+/* 	}; */
+
+/* 	tlv320aic3106: tlv320aic3106@1b { */
+/* 		#sound-dai-cells = <0>; */
+/* 		compatible = "ti,tlv320aic3106"; */
+/* 		reg = <0x1b>; */
+/* 		status = "okay"; */
+
+/* 		/\* Regulators *\/ */
+/* 		AVDD-supply = <&v3_3d_reg>; */
+/* 		IOVDD-supply = <&v3_3d_reg>; */
+/* 		DRVDD-supply = <&v3_3d_reg>; */
+/* 		DVDD-supply = <&v1_8d_reg>; */
+/* 	}; */
+/* }; */
+
+/* &lcdc { */
+/* 	status = "okay"; */
+
+/* 	blue-and-red-wiring = "crossed"; */
+/* }; */
+
+/* &elm { */
+/* 	status = "okay"; */
+/* }; */
+
+/* &epwmss0 { */
+/* 	status = "okay"; */
+
+/* 	ecap0: ecap@48300100 { */
+/* 		status = "okay"; */
+/* 		pinctrl-names = "default"; */
+/* 		pinctrl-0 = <&ecap0_pins>; */
+/* 	}; */
+/* }; */
+
+/* &gpmc { */
+/* 	status = "okay"; */
+/* 	pinctrl-names = "default"; */
+/* 	pinctrl-0 = <&nandflash_pins_s0>; */
+/* 	ranges = <0 0 0x08000000 0x1000000>;	/\* CS0: 16MB for NAND *\/ */
+/* 	nand@0,0 { */
+/* 		compatible = "ti,omap2-nand"; */
+/* 		reg = <0 0 4>; /\* CS0, offset 0, IO size 4 *\/ */
+/* 		interrupt-parent = <&gpmc>; */
+/* 		interrupts = <0 IRQ_TYPE_NONE>, /\* fifoevent *\/ */
+/* 			     <1 IRQ_TYPE_NONE>;	/\* termcount *\/ */
+/* 		rb-gpios = <&gpmc 0 GPIO_ACTIVE_HIGH>; /\* gpmc_wait0 *\/ */
+/* 		ti,nand-xfer-type = "prefetch-dma"; */
+/* 		ti,nand-ecc-opt = "bch8"; */
+/* 		ti,elm-id = <&elm>; */
+/* 		nand-bus-width = <8>; */
+/* 		gpmc,device-width = <1>; */
+/* 		gpmc,sync-clk-ps = <0>; */
+/* 		gpmc,cs-on-ns = <0>; */
+/* 		gpmc,cs-rd-off-ns = <44>; */
+/* 		gpmc,cs-wr-off-ns = <44>; */
+/* 		gpmc,adv-on-ns = <6>; */
+/* 		gpmc,adv-rd-off-ns = <34>; */
+/* 		gpmc,adv-wr-off-ns = <44>; */
+/* 		gpmc,we-on-ns = <0>; */
+/* 		gpmc,we-off-ns = <40>; */
+/* 		gpmc,oe-on-ns = <0>; */
+/* 		gpmc,oe-off-ns = <54>; */
+/* 		gpmc,access-ns = <64>; */
+/* 		gpmc,rd-cycle-ns = <82>; */
+/* 		gpmc,wr-cycle-ns = <82>; */
+/* 		gpmc,bus-turnaround-ns = <0>; */
+/* 		gpmc,cycle2cycle-delay-ns = <0>; */
+/* 		gpmc,clk-activation-ns = <0>; */
+/* 		gpmc,wr-access-ns = <40>; */
+/* 		gpmc,wr-data-mux-bus-ns = <0>; */
+/* 		/\* MTD partition table *\/ */
+/* 		/\* All SPL-* partitions are sized to minimal length */
+/* 		 * which can be independently programmable. For */
+/* 		 * NAND flash this is equal to size of erase-block *\/ */
+/* 		#address-cells = <1>; */
+/* 		#size-cells = <1>; */
+/* 		partition@0 { */
+/* 			label = "NAND.SPL"; */
+/* 			reg = <0x00000000 0x000020000>; */
+/* 		}; */
+/* 		partition@1 { */
+/* 			label = "NAND.SPL.backup1"; */
+/* 			reg = <0x00020000 0x00020000>; */
+/* 		}; */
+/* 		partition@2 { */
+/* 			label = "NAND.SPL.backup2"; */
+/* 			reg = <0x00040000 0x00020000>; */
+/* 		}; */
+/* 		partition@3 { */
+/* 			label = "NAND.SPL.backup3"; */
+/* 			reg = <0x00060000 0x00020000>; */
+/* 		}; */
+/* 		partition@4 { */
+/* 			label = "NAND.u-boot-spl-os"; */
+/* 			reg = <0x00080000 0x00040000>; */
+/* 		}; */
+/* 		partition@5 { */
+/* 			label = "NAND.u-boot"; */
+/* 			reg = <0x000C0000 0x00100000>; */
+/* 		}; */
+/* 		partition@6 { */
+/* 			label = "NAND.u-boot-env"; */
+/* 			reg = <0x001C0000 0x00020000>; */
+/* 		}; */
+/* 		partition@7 { */
+/* 			label = "NAND.u-boot-env.backup1"; */
+/* 			reg = <0x001E0000 0x00020000>; */
+/* 		}; */
+/* 		partition@8 { */
+/* 			label = "NAND.kernel"; */
+/* 			reg = <0x00200000 0x00800000>; */
+/* 		}; */
+/* 		partition@9 { */
+/* 			label = "NAND.file-system"; */
+/* 			reg = <0x00A00000 0x0F600000>; */
+/* 		}; */
+/* 	}; */
+/* }; */
+
+/* #include "tps65910.dtsi" */
+
+/* &mcasp1 { */
+/* 	#sound-dai-cells = <0>; */
+/* 	pinctrl-names = "default", "sleep"; */
+/* 	pinctrl-0 = <&mcasp1_pins>; */
+/* 	pinctrl-1 = <&mcasp1_pins_sleep>; */
+
+/* 	status = "okay"; */
+
+/* 	op-mode = <0>;          /\* MCASP_IIS_MODE *\/ */
+/* 	tdm-slots = <2>; */
+/* 	/\* 4 serializers *\/ */
+/* 	serial-dir = <  /\* 0: INACTIVE, 1: TX, 2: RX *\/ */
+/* 		0 0 1 2 */
+/* 	>; */
+/* 	tx-num-evt = <32>; */
+/* 	rx-num-evt = <32>; */
+/* }; */
+
+/* &tps { */
+/* 	vcc1-supply = <&vbat>; */
+/* 	vcc2-supply = <&vbat>; */
+/* 	vcc3-supply = <&vbat>; */
+/* 	vcc4-supply = <&vbat>; */
+/* 	vcc5-supply = <&vbat>; */
+/* 	vcc6-supply = <&vbat>; */
+/* 	vcc7-supply = <&vbat>; */
+/* 	vccio-supply = <&vbat>; */
+
+/* 	regulators { */
+/* 		vrtc_reg: regulator@0 { */
+/* 			regulator-always-on; */
+/* 		}; */
+
+/* 		vio_reg: regulator@1 { */
+/* 			regulator-always-on; */
+/* 		}; */
+
+/* 		vdd1_reg: regulator@2 { */
+/* 			/\* VDD_MPU voltage limits 0.95V - 1.26V with +/-4% tolerance *\/ */
+/* 			regulator-name = "vdd_mpu"; */
+/* 			regulator-min-microvolt = <912500>; */
+/* 			regulator-max-microvolt = <1351500>; */
+/* 			regulator-boot-on; */
+/* 			regulator-always-on; */
+/* 		}; */
+
+/* 		vdd2_reg: regulator@3 { */
+/* 			/\* VDD_CORE voltage limits 0.95V - 1.1V with +/-4% tolerance *\/ */
+/* 			regulator-name = "vdd_core"; */
+/* 			regulator-min-microvolt = <912500>; */
+/* 			regulator-max-microvolt = <1150000>; */
+/* 			regulator-boot-on; */
+/* 			regulator-always-on; */
+/* 		}; */
+
+/* 		vdd3_reg: regulator@4 { */
+/* 			regulator-always-on; */
+/* 		}; */
+
+/* 		vdig1_reg: regulator@5 { */
+/* 			regulator-always-on; */
+/* 		}; */
+
+/* 		vdig2_reg: regulator@6 { */
+/* 			regulator-always-on; */
+/* 		}; */
+
+/* 		vpll_reg: regulator@7 { */
+/* 			regulator-always-on; */
+/* 		}; */
+
+/* 		vdac_reg: regulator@8 { */
+/* 			regulator-always-on; */
+/* 		}; */
+
+/* 		vaux1_reg: regulator@9 { */
+/* 			regulator-always-on; */
+/* 		}; */
+
+/* 		vaux2_reg: regulator@10 { */
+/* 			regulator-always-on; */
+/* 		}; */
+
+/* 		vaux33_reg: regulator@11 { */
+/* 			regulator-always-on; */
+/* 		}; */
+
+/* 		vmmc_reg: regulator@12 { */
+/* 			regulator-min-microvolt = /\* von kurz uebernommen: *\/ <3300000> /\*original von am33xx_eval oder so aehnlich: <1800000>*\/; */
+/* 			regulator-max-microvolt = <3300000>; */
+/* 			regulator-always-on; */
+/* 		}; */
+/* 	}; */
+/* }; */
+
+&mac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cpsw_default>;
+	slaves = <1>;
+	status = "okay";
+};
+
+&davinci_mdio {
+	pinctrl-names = "default";
+	pinctrl-0 = <&davinci_mdio_default>;
+	status = "okay";
+};
+
+&cpsw_emac0 {
+	phy_id = <&davinci_mdio>, <1>;
+	phy-mode = "mii";
+};
+
+/* &tscadc { */
+/* 	status = "okay"; */
+/* 	tsc { */
+/* 		ti,wires = <4>; */
+/* 		ti,x-plate-resistance = <200>; */
+/* 		ti,coordinate-readouts = <5>; */
+/* 		ti,wire-config = <0x00 0x11 0x22 0x33>; */
+/* 		ti,charge-delay = <0x400>; */
+/* 	}; */
+
+/* 	adc { */
+/* 		ti,adc-channels = <4 5 6 7>; */
+/* 	}; */
+/* }; */
+/* #endif */
+
+/* #if 0 */
+/* &sham { */
+/* 	status = "okay"; */
+/* }; */
+
+/* &aes { */
+/* 	status = "okay"; */
+/* }; */
+
+/* &dcan1 { */
+/* 	status = "disabled";	/\* Enable only if Profile 1 is selected *\/ */
+/* 	pinctrl-names = "default"; */
+/* 	pinctrl-0 = <&dcan1_pins_default>; */
+/* }; */
+
+/* &rtc { */
+/* 	clocks = <&clk_32768_ck>, <&l4_per_clkctrl AM3_CLKDIV32K_CLKCTRL 0>; */
+/* 	clock-names = "ext-clk", "int-clk"; */
+/* }; */
+
+/* #endif */
+
diff --color -rupN uboot-2019.04/arch/arm/include/asm/arch-am33xx/mux_am33xx.h uboot.b/arch/arm/include/asm/arch-am33xx/mux_am33xx.h
--- uboot-2019.04/arch/arm/include/asm/arch-am33xx/mux_am33xx.h	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/arch/arm/include/asm/arch-am33xx/mux_am33xx.h	2020-12-14 08:42:07.908840579 +0100
@@ -25,12 +25,29 @@
 /* PAD Control Fields */
 #define SLEWCTRL	(0x1 << 6)
 #define RXACTIVE	(0x1 << 5)
+// preitinger: Verwendung von PULLDOWN_EN und PULLUP_EN nur sinnvoll falls nicht PULLUDDIS verwendet
+// dann definiert dies ob pull down bzw. pull up
 #define PULLDOWN_EN	(0x0 << 4) /* Pull Down Selection */
 #define PULLUP_EN	(0x1 << 4) /* Pull Up Selection */
-#define PULLUDEN	(0x0 << 3) /* Pull up enabled */
+// preitinger: verwendung von PULLUDEN eigentlich ueberfluessig, nur zur lesbarkeit gegenstueck zu PULLUDDIS
+#define PULLUDEN	(0x0 << 3) /* Pull up enabled */ /* preitinger: dies muss pull up/down enabled heissen!!! */
+// preitinger: PULLUDDIS muss gesetzt sein fuer no-pull
 #define PULLUDDIS	(0x1 << 3) /* Pull up disabled */
 #define MODE(val)	val	/* used for Readability */
 
+/**
+ * preitinger: Beispiele
+ * pin input no pull:
+ * RXACTIVE | PULLUDDIS
+ *
+ * pin output pull-up:
+ * PULLUDEN | PULLUP_EN oder nur PULLUP_EN
+ *
+ * pin input pull-down:
+ * RX_ACTIVE | PULLUDEN | PULLDOWN_EN oder nur RX_ACTIVE
+ *
+ */
+
 /*
  * PAD CONTROL OFFSETS
  * Field names corresponds to the pad signal name
diff --color -rupN uboot-2019.04/board/ti/am335x/board.c uboot.b/board/ti/am335x/board.c
--- uboot-2019.04/board/ti/am335x/board.c	2020-12-14 14:53:34.630386873 +0100
+++ uboot.b/board/ti/am335x/board.c	2020-12-14 08:42:20.532888627 +0100
@@ -41,6 +41,10 @@
 #include "board.h"
 #include "hash-string.h"
 
+#include <linux/delay.h>
+#include "PR.h"
+#include <i2c.h>
+
 DECLARE_GLOBAL_DATA_PTR;
 
 /* GPIO that controls power to DDR on EVM-SK */
@@ -73,6 +77,7 @@ void do_board_detect(void)
 {
 	enable_i2c0_pin_mux();
 #ifndef CONFIG_DM_I2C
+#warning CONFIG_DM_I2C defined
 	i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED, CONFIG_SYS_OMAP24_I2C_SLAVE);
 #endif
 	if (ti_i2c_eeprom_am_get(CONFIG_EEPROM_BUS_ADDRESS,
@@ -122,6 +127,32 @@ void do_board_detect(void)
 #define M_BBG1	0x01
 #define M_OS00	0x02
 
+
+#define CV_EEPROM_CHIP 0x50
+#define CV_EEPROM_BOOTCOUNT_ADDR 0x10
+#define CV_EEPROM_ALEN 2
+
+/**
+ * @return -1 on error, otherwise bootcount between 0 and 255
+ */
+static int eeprom_bootcount_get(void) {
+	uint8_t buf;
+	int res = i2c_read(CV_EEPROM_CHIP, CV_EEPROM_BOOTCOUNT_ADDR, CV_EEPROM_ALEN, &buf, 1);
+	if (res) {
+		return -1;
+	}
+	return (int) buf & 0x000000ff;
+}
+
+static int eeprom_bootcount_set(int count) {
+	// neuer zaehler im eeprom ab (i2c0, chip 0x50, adresse 0x10
+	uint8_t buf = (uint8_t) count;
+	int res = i2c_write(CV_EEPROM_CHIP, CV_EEPROM_BOOTCOUNT_ADDR, CV_EEPROM_ALEN, &buf, 1);
+	PRE("i2c_write: res=%d\n", res);
+	return res;
+
+}
+
 static int probe_cape_eeprom(struct am335x_cape_eeprom_id *cape_header)
 {
 	unsigned char addr;
@@ -691,17 +722,156 @@ static struct emif_regs ddr3_icev2_emif_
 #ifdef CONFIG_SPL_OS_BOOT
 int spl_start_uboot(void)
 {
-#ifdef CONFIG_SPL_SERIAL_SUPPORT
+	int res;
+#if 0 // TODO just testing i2c functions
+	{
+		const int chip=0x50;
+		const int busnum=0;
+		struct udevice *bus, *dev;
+		uint8_t buf[5];
+
+		res = uclass_get_device_by_seq(UCLASS_I2C, busnum, &bus);
+		PRE("res=%d\n", res);
+
+		if (res == 0) {
+			res = i2c_get_chip(bus, chip, 1, &dev);
+			PRE("res=%d\n", res);
+
+			if (res == 0) {
+				res = dm_i2c_read(dev, 0, buf, 5);
+				PRE("buf[0]=%d\n", buf[0]);
+			}
+		}
+	}
+
+#endif
+
+
+#if 1 //def ORIG_SRC
+	printf("preitinger: spl_start_uboot start\n");
+# ifdef CONFIG_SPL_SERIAL_SUPPORT
+	printf("preitinger: in ifdef 1?\n");
 	/* break into full u-boot on 'c' */
-	if (serial_tstc() && serial_getc() == 'c')
+	if (serial_tstc() && serial_getc() == 'c') {
+		res = eeprom_bootcount_set(0);
+		if (res) {
+			PRE("eeprom_boot_count_set: res=%d\n", res);
+		}
+		PRE1("return 1 because of 'c'??\n");
 		return 1;
-#endif
+	}
+# endif
+PRE1("vor ifdef CONFIG_SPL_ENV_SUPPORT\n");
+# ifdef CONFIG_SPL_ENV_SUPPORT
+	printf("preitinger: in ifdef 2?\n");
+	res = env_init();
+	PRE("res of env_init: %d\n", res);
+	res = env_load();
+	PRE("res of env_load: %d\n", res);
+#ifndef CONFIG_CV_CLEAR_NAND_ENV
+	// nichts mehr
+//	{ // TODO REMOVE ME after testing
+//		int oldValThenRes = env_get_ulong("my_test_count", 10, 0);
+//		PRE("Zaehle my_test_count hoch (oldVal=%d) ...\n", oldValThenRes);
+//		oldValThenRes = env_set_ulong("my_test_count", oldValThenRes + 1);
+//		PRE("env_set_ulong: resetres=%d\n", oldValThenRes);
+//		oldValThenRes = env_save();
+//		PRE("env_save: res=%d\n", oldValThenRes);
+//	}
+//	{
+//		// TODO test only
+//		// neuer zaehler im eeprom ab (i2c0, chip 0x50, adresse 0x10
+//		uint8_t buf;
+//		int res = i2c_read(0x50, 0x10, 2, &buf, 1);
+//		PRE("i2c_read: res=%d\n", res);
+//		PRE("old val: 0x%x\n", buf);
+//		++buf;
+//		res = i2c_write(0x50, 0x10, 2, &buf, 1);
+//		PRE("i2c_write: res=%d\n", res);
+//	}
+#else
+	PRE1("CONFIG_CV_CLEAR_NAND_ENV defined - vor set_default_env()\n");
+	const char* checkBootCmd = env_get("bootcmd");
+	PRE("checkBootCmd vor set_default_env(): '%s'\n", checkBootCmd);
+	set_default_env(NULL, 0);
+	PRE("res of env_save: %d\n", res);
+	checkBootCmd = env_get("bootcmd");
+	PRE("checkBootCmd nach env_save(): '%s'\n", checkBootCmd);
+	res = eeprom_bootcount_set(0);
+	if (res) {
+		PRE("eeprom_boot_count_set: res=%d\n", res);
+	}
+	return 1; // u-boot starten, nicht direkt linux os, d.h. kein falcon mode
+#endif
+	int preitinger_res = env_get_yesno("boot_os");
+	if (env_get_yesno("boot_os") != 1) {
+		printf("preitinger: return 1 wegen boot_os?! - wert: %d\n", preitinger_res);
+		res = eeprom_bootcount_set(0);
+		if (res) {
+			PRE("eeprom_boot_count_set: res=%d\n", res);
+		}
+		return 1;
+	}
+	{
+		int eeprom_bootcount = eeprom_bootcount_get();
+		if (eeprom_bootcount < 0) {
+			PRE("eeprom_bootcount=%d\n", eeprom_bootcount);
+		} else {
+			if (eeprom_bootcount >= CONFIG_CV_BOOTCOUNT_LIMIT) {
+				PRE("CONFIG_CV_BOOTCOUNT_LIMIT=%d erreicht, boote ohne Falcon Mode!\n", CONFIG_CV_BOOTCOUNT_LIMIT);
+				// WICHTIG! hier nicht (mehr) bootcount zuruecksetzen, damit u-boot anschliessend
+				// weiss dass es einen fallback durchfuehren muss wegen des erreichten boot limits!
+				// daher folgendes NICHT:
+//				res = eeprom_bootcount_set(0);
+//				if (res) {
+//					PRE("eeprom_boot_count_set: res=%d\n", res);
+//				}
 
-#ifdef CONFIG_SPL_ENV_SUPPORT
-	env_init();
-	env_load();
-	if (env_get_yesno("boot_os") != 1)
+				return 1;
+			} else {
+				++eeprom_bootcount;
+				res = eeprom_bootcount_set(eeprom_bootcount);
+				if (res) {
+					PRE("eeprom_boot_count_set: res=%d\n", res);
+				} else {
+					PRE("eeprom_bootcount incremented to %d\n", eeprom_bootcount);
+				}
+			}
+		}
+	}
+# endif
+	printf("preitinger:spl_start_uboot returning 0\n");
+
+#else
+
+# ifdef CONFIG_SPL_SERIAL_SUPPORT
+	PRE1("in ifdef CONFIG_SPL_SERIAL_SUPPORT\n");
+	/* break into full u-boot on 'c' */
+	if (serial_tstc() && serial_getc() == 'c') {
+		printf("preitinger: 1 wegen 'c'\n");
 		return 1;
+	}
+# endif
+
+# ifdef CONFIG_SPL_ENV_SUPPORT
+	PRE1("in ifdef CONFIG_SPL_ENV_SUPPORT\n");
+	int res = env_init();
+	PRE("env_init code: %d\n", res);
+	if (res == 0) {
+		res = env_load();
+		PRE("env_load code: %d\n", res);
+		if (res == 0) {
+			PRE1("vor env_get\n");
+			char *s = env_get("my_tftp_prep");
+			PRE("my_tftp_prep: s=%u\n", (unsigned) s);
+			if (s) {
+				PRE("inhalt my_tftp_prep: '%s'\n", s);
+			}
+		}
+	}
+	return 1;
+
+# endif
 #endif
 
 	return 0;
@@ -1179,11 +1349,35 @@ void rtc32k_enable(void)
 }
 #endif
 
+extern void nand_init(void);
+
+void am33xx_spl_board_init(void) {
+//void spl_board_init(void) {
+	PRE1("gut\n");
+#if defined(CONFIG_HW_WATCHDOG)
+	WATCHDOG_RESET();
+//	// TODO preitinger: remove the following loop after test of watchdog reset
+//	for (int i = 0; true; ++i) {
+//		PRE("[%d]: Schlafe ...\n", i);
+//		mdelay(1000*5);
+//		PRE1("  Done.\n");
+//	}
+#endif
+	hw_watchdog_init();
+
+	// TODO remove me after testing u-boot;
+	// or better disable watchdog just when interactive mode is entered, i.e. CLI is opened
+	hw_watchdog_disable();
+
+	nand_init();
+}
+
 /*
  * Basic board specific setup.  Pinmux has been handled already.
  */
 int board_init(void)
 {
+	PRE1("begin\n");
 	u32 sys_reboot, sys_rtc_osc;
 
 	sys_reboot = readl(PRM_RSTST);
@@ -1209,9 +1403,7 @@ int board_init(void)
 		puts("RTC 32KCLK Source: Internal.\n");
 	}
 
-#if defined(CONFIG_HW_WATCHDOG)
-	hw_watchdog_init();
-#endif
+	// preitinger: bereits in spl_init:
 
 	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
 #if defined(CONFIG_NOR) || defined(CONFIG_NAND)
@@ -1290,6 +1482,140 @@ int board_init(void)
 	}
 #endif
 
+	// preitinger: schon in spl:
+//	hw_watchdog_init();
+
+#if 0 // TODO just testing i2c functions
+	{
+		int res;
+		const int chip=0x50;
+		const int busnum=0;
+		struct udevice *bus, *dev;
+		uint8_t buf[5];
+
+		res = uclass_get_device_by_seq(UCLASS_I2C, busnum, &bus);
+		PRE("res=%d\n", res);
+
+		if (res == 0) {
+			res = i2c_get_chip(bus, chip, 1, &dev);
+			PRE("res=%d\n", res);
+
+			if (res == 0) {
+				res = dm_i2c_read(dev, 0, buf, 5);
+				PRE("buf[0]=%d\n", buf[0]);
+			}
+		}
+	}
+
+#endif
+
+#if 0 // TODO just testing i2c functions
+	// unnoetige verwendung von i2c_get_adapter? siehe naechster versuche
+	const uint8_t chip = 0x50;
+	uint addr = 0;
+	const int alen = 2;
+	const int buflen = 8;
+	uint8_t buffer[buflen];
+	int res;
+
+	struct i2c_adapter* x = i2c_get_adapter(0);
+	PRE("x=%p\n", x);
+	res = x->read(x, chip, addr, alen, buffer, buflen);
+	PRE("read: res=%d\n", res);
+	for (int i = 0; i < buflen; ++i) {
+		PRE("buffer[%d]=0x%x\n", i, buffer[i]);
+	}
+	buffer[0] = 0xbb;
+	res = x->write(x, chip, addr, alen, buffer, 1);
+	PRE("write: res=%d\n", res);
+	buffer[0] = 0;
+	res = x->read(x, chip, addr, alen, buffer, buflen);
+	PRE("2. read: res=%d\n", res);
+	for (int i = 0; i < buflen; ++i) {
+		PRE("buffer[%d]=0x%x\n", i, buffer[i]);
+	}
+
+
+
+#endif
+
+	// TODO folgendes nur zum testen der i2c schnittstelle
+#if 0 // geht zumindest im u-boot, auch in SPL?
+	const uint8_t chip = 0x50;
+	uint addr = 0;
+	const int alen = 2;
+	const int buflen = 8;
+	uint8_t buffer[buflen];
+	int res;
+
+	res = i2c_read(chip, addr, alen, buffer, buflen);
+	PRE("read: res=%d\n", res);
+	for (int i = 0; i < buflen; ++i) {
+		PRE("buffer[%d]=0x%x\n", i, buffer[i]);
+	}
+	buffer[0] = 0xbb;
+	res = i2c_write(chip, addr, alen, buffer, 1);
+	PRE("write: res=%d\n", res);
+	buffer[0] = 0;
+	res = i2c_read(chip, addr, alen, buffer, buflen);
+	PRE("2. read: res=%d\n", res);
+	for (int i = 0; i < buflen; ++i) {
+		PRE("buffer[%d]=0x%x\n", i, buffer[i]);
+	}
+
+#endif
+
+#if 0
+	{
+		// fallback notwendig?
+
+		int eeprom_bootcount = eeprom_bootcount_get();
+
+		if (eeprom_bootcount < 0) {
+			PRE("eeprom_bootcount=%d\n", eeprom_bootcount);
+			// FEHLER!
+		} else {
+
+			if (eeprom_bootcount >= CONFIG_CV_BOOTCOUNT_LIMIT) {
+				PRE("CONFIG_CV_BOOTCOUNT_LIMIT=%d erreicht, boote ohne Falcon Mode!\n", CONFIG_CV_BOOTCOUNT_LIMIT);
+
+				int fallback_allowed = env_get_yesno("my_fallback_allowed");
+				PRE("fallback_allowed=%d\n", fallback_allowed);
+
+				if (fallback_allowed != -1 && fallback_allowed)  {
+					int res;
+					ulong old = env_get_ulong("my_boot_switch", 10, 0);
+					if (old != 0 && old != 1) {
+						PRE("Unerwarteter Wert fuer my_boot_switch: %d\n", (int) old);
+						// korrigiere zu 0
+						old = 0;
+					}
+					res = env_set_ulong("my_boot_switch", (ulong) (1 - old));
+					if (res) {
+						PRE("env_set_ulong for my_boot_switch: %d\n", res);
+					}
+					res = env_set("my_boot_switch_dirty", "1");
+					if (res) {
+						PRE("env_set for my_boot_switch_dirty: %d\n", res);
+					}
+					res = env_set("my_fallback_allowed", "0");
+					if (res) {
+						PRE("env_set for my_fallback_allowed: %d\n", res);
+					}
+					res = env_save();
+					if (res) {
+						PRE("env_save(): %d\n", res);
+					}
+				} else {
+					PRE1("boot limit erreicht, aber fallback nicht moeglich. Wir sind am ENDE! ;-)\n");
+				}
+
+				// TODO
+			}
+		}
+	}
+#endif
+
 	return 0;
 }
 
@@ -1404,6 +1730,69 @@ int board_late_init(void)
 #endif
 #endif
 
+	// preitinger:
+#ifdef CONFIG_CV_CLEAR_NAND_ENV
+	set_default_env(NULL, 0);
+//	env_set("bootcmd", "if mmc rescan; then if load mmc 0:1 $loadaddr /boot.scr; then source $loadaddr; fi; fi; run my_nand_boot;");
+#endif
+
+#if 1
+	{
+		// fallback notwendig?
+
+		PRE1("fallback notwendig? (nun in late_init)\n");
+
+		int eeprom_bootcount = eeprom_bootcount_get();
+
+		if (eeprom_bootcount < 0) {
+			PRE("eeprom_bootcount=%d\n", eeprom_bootcount);
+			// FEHLER!
+		} else {
+
+			if (eeprom_bootcount >= CONFIG_CV_BOOTCOUNT_LIMIT) {
+				PRE("CONFIG_CV_BOOTCOUNT_LIMIT=%d erreicht!\n", CONFIG_CV_BOOTCOUNT_LIMIT);
+
+				int fallback_allowed = env_get_yesno("my_fallback_allowed");
+				PRE("fallback_allowed=%d\n", fallback_allowed);
+
+				if (fallback_allowed != -1 && fallback_allowed)  {
+					int res;
+					ulong old = env_get_ulong("my_boot_switch", 10, 0);
+					if (old != 0 && old != 1) {
+						PRE("Unerwarteter Wert fuer my_boot_switch: %d\n", (int) old);
+						// korrigiere zu 0
+						old = 0;
+					}
+					res = env_set_ulong("my_boot_switch", (ulong) (1 - old));
+					if (res) {
+						PRE("env_set_ulong for my_boot_switch: %d\n", res);
+					}
+					res = env_set("my_boot_switch_dirty", "1");
+					if (res) {
+						PRE("env_set for my_boot_switch_dirty: %d\n", res);
+					}
+					res = env_set("my_fallback_allowed", "0");
+					if (res) {
+						PRE("env_set for my_fallback_allowed: %d\n", res);
+					}
+					res = env_save();
+					if (res) {
+						PRE("env_save(): %d\n", res);
+					}
+					res = eeprom_bootcount_set(0);
+					if (res) {
+						PRE("eeprom_bootcount_set(0): %d\n", res);
+					}
+				} else {
+					PRE1("boot limit erreicht, aber fallback nicht moeglich. Wir sind am ENDE! ;-)\n");
+				}
+
+				// TODO
+			}
+		}
+	}
+#endif
+
 	return 0;
 }
 #endif
@@ -1623,3 +2012,8 @@ U_BOOT_DEVICE(am335x_mmc1) = {
 	.platdata = &am335x_mmc1_platdata,
 };
 #endif
+
+void spl_board_prepare_for_linux(void)
+{
+	printf("preitinger: spl_board_prepare_for_linux\n");
+}
diff --color -rupN uboot-2019.04/board/ti/am335x/board.c~ uboot.b/board/ti/am335x/board.c~
--- uboot-2019.04/board/ti/am335x/board.c~	1970-01-01 01:00:00.000000000 +0100
+++ uboot.b/board/ti/am335x/board.c~	2020-12-14 08:42:20.528888613 +0100
@@ -0,0 +1,1631 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * board.c
+ *
+ * Board functions for TI AM335X based boards
+ *
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <spl.h>
+#include <serial.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/omap.h>
+#include <asm/arch/ddr_defs.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/clk_synthesizer.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/mmc_host_def.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/mem.h>
+#include <asm/io.h>
+#include <asm/emif.h>
+#include <asm/gpio.h>
+#include <asm/omap_common.h>
+#include <asm/omap_sec_common.h>
+#include <asm/omap_mmc.h>
+#include <asm/davinci_rtc.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <cpsw.h>
+#include <power/tps65217.h>
+#include <power/tps65910.h>
+#include <environment.h>
+#include <watchdog.h>
+#include <environment.h>
+#include "../common/board_detect.h"
+#include "board.h"
+#include "hash-string.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* GPIO that controls power to DDR on EVM-SK */
+#define GPIO_TO_PIN(bank, gpio)		(32 * (bank) + (gpio))
+#define GPIO_DDR_VTT_EN		GPIO_TO_PIN(0, 7)
+#define ICE_GPIO_DDR_VTT_EN	GPIO_TO_PIN(0, 18)
+#define GPIO_PR1_MII_CTRL	GPIO_TO_PIN(3, 4)
+#define GPIO_MUX_MII_CTRL	GPIO_TO_PIN(3, 10)
+#define GPIO_FET_SWITCH_CTRL	GPIO_TO_PIN(0, 7)
+#define GPIO_PHY_RESET		GPIO_TO_PIN(2, 5)
+#define GPIO_ETH0_MODE		GPIO_TO_PIN(0, 11)
+#define GPIO_ETH1_MODE		GPIO_TO_PIN(1, 26)
+
+static struct ctrl_dev *cdev = (struct ctrl_dev *)CTRL_DEVICE_BASE;
+
+#define GPIO0_RISINGDETECT	(AM33XX_GPIO0_BASE + OMAP_GPIO_RISINGDETECT)
+#define GPIO1_RISINGDETECT	(AM33XX_GPIO1_BASE + OMAP_GPIO_RISINGDETECT)
+
+#define GPIO0_IRQSTATUS1	(AM33XX_GPIO0_BASE + OMAP_GPIO_IRQSTATUS1)
+#define GPIO1_IRQSTATUS1	(AM33XX_GPIO1_BASE + OMAP_GPIO_IRQSTATUS1)
+
+#define GPIO0_IRQSTATUSRAW	(AM33XX_GPIO0_BASE + 0x024)
+#define GPIO1_IRQSTATUSRAW	(AM33XX_GPIO1_BASE + 0x024)
+
+/*
+ * Read header information from EEPROM into global structure.
+ */
+#ifdef CONFIG_TI_I2C_BOARD_DETECT
+void do_board_detect(void)
+{
+	enable_i2c0_pin_mux();
+#ifndef CONFIG_DM_I2C
+	i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED, CONFIG_SYS_OMAP24_I2C_SLAVE);
+#endif
+	if (ti_i2c_eeprom_am_get(CONFIG_EEPROM_BUS_ADDRESS,
+				 CONFIG_EEPROM_CHIP_ADDRESS))
+		printf("ti_i2c_eeprom_init failed\n");
+
+	//hack-ish, needs to mux'ed early, in do_cape_detect was too late...
+	enable_i2c2_pin_mux();
+#ifndef CONFIG_DM_I2C
+	i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED2, CONFIG_SYS_OMAP24_I2C_SLAVE2);
+#endif
+}
+#endif
+
+#define CAPE_EEPROM_ADDR0	0x54
+#define CAPE_EEPROM_ADDR1	0x55
+#define CAPE_EEPROM_ADDR2	0x56
+#define CAPE_EEPROM_ADDR3	0x57
+
+#define NOT_POP		0x0
+#define PINS_TAKEN	0x0
+
+#define UNK_BASE_DTB	0x0
+#define BB_BASE_DTB	0x1
+#define BBB_BASE_DTB	0x2
+#define BBGW_BASE_DTB	0x3
+#define BBBL_BASE_DTB	0x4
+#define BBE_BASE_DTB	0x5
+
+#define BBB_EMMC	0x1
+
+#define BBB_TDA998X_AUDIO	0x1
+#define BBB_TDA998X_NAUDIO	0x2
+#define BBB_ADV7511_AUDIO	0x3
+#define BBB_ADV7511_NAUDIO	0x4
+
+#define BBB_ADC		0x1
+
+#define BBBW_WL1835	0x1
+#define BBGW_WL1835	0x2
+
+#define CAPE_UNIVERSAL	0x0
+#define CAPE_UNIVERSAL_BBB	0x01
+#define CAPE_UNIVERSAL_BBG	0x02
+#define CAPE_UNIVERSAL_BBGW	0x03
+
+#define M_BBG1	0x01
+#define M_OS00	0x02
+
+static int probe_cape_eeprom(struct am335x_cape_eeprom_id *cape_header)
+{
+	unsigned char addr;
+	/* /lib/firmware/BB-CAPE-DISP-CT4-00A0.dtbo */
+	/* 14 + 16 + 1 + 4 + 5 = 40 */
+	char cape_overlay[40];
+	char process_cape_part_number[16];
+	char end_part_number;
+	char cape_overlay_pass_to_kernel[18];
+
+	//Don't forget about the BeagleBone Classic (White)
+	char base_dtb=UNK_BASE_DTB;
+	char virtual_emmc=NOT_POP;
+	char virtual_video=NOT_POP;
+	char virtual_audio=NOT_POP;
+	char virtual_wireless=NOT_POP;
+	char cape_universal=CAPE_UNIVERSAL;
+	char virtual_adc=NOT_POP;
+	char model=NOT_POP;
+
+	char *name = NULL;
+
+	if (board_is_bone_lt()) {
+		puts("BeagleBone Black:\n");
+		base_dtb=BBB_BASE_DTB;
+		virtual_emmc=BBB_EMMC;
+		virtual_video=BBB_TDA998X_AUDIO;
+		virtual_audio=BBB_TDA998X_AUDIO;
+		virtual_wireless=NOT_POP;
+		virtual_adc=BBB_ADC;
+		cape_universal=CAPE_UNIVERSAL_BBB;
+		name = "A335BNLT";
+
+		if (!strncmp(board_ti_get_rev(), "BLA", 3)) {
+			puts("Model: BeagleBoard.org BeagleBone Blue:\n");
+			/* Special case */
+			base_dtb=BBBL_BASE_DTB;
+			virtual_emmc=NOT_POP;
+			virtual_video=NOT_POP;
+			virtual_audio=NOT_POP;
+			virtual_wireless=NOT_POP;
+			virtual_adc=BBB_ADC;
+			cape_universal=CAPE_UNIVERSAL;
+			name = "BBBL";
+		}
+		if (!strncmp(board_ti_get_rev(), "BW", 2)) {
+			puts("Model: BeagleBoard.org BeagleBone Black Wireless:\n");
+			virtual_wireless=BBBW_WL1835;
+			name = "BBBW";
+		}
+		if (!strncmp(board_ti_get_rev(), "BBG", 3)) {
+			/* catches again in board_is_bbg1() */
+			//puts("Model: SeeedStudio BeagleBone Green:\n");
+			virtual_video=NOT_POP;
+			virtual_audio=NOT_POP;
+			cape_universal=CAPE_UNIVERSAL_BBG;
+			name = "BBG1";
+			model=M_BBG1;
+		}
+		if (!strncmp(board_ti_get_rev(), "GW1", 3)) {
+			puts("Model: SeeedStudio BeagleBone Green Wireless:\n");
+			base_dtb=BBGW_BASE_DTB;
+			virtual_video=NOT_POP;
+			virtual_audio=NOT_POP;
+			virtual_wireless=BBGW_WL1835;
+			cape_universal=CAPE_UNIVERSAL_BBGW;
+		}
+		if (!strncmp(board_ti_get_rev(), "AIA", 3)) {
+			puts("Model: Arrow BeagleBone Black Industrial:\n");
+			virtual_video=BBB_ADV7511_AUDIO;
+			virtual_audio=BBB_ADV7511_AUDIO;
+			cape_universal=CAPE_UNIVERSAL;
+		}
+		if (!strncmp(board_ti_get_rev(), "EIA", 3)) {
+			puts("Model: Element14 BeagleBone Black Industrial:\n");
+		}
+		if (!strncmp(board_ti_get_rev(), "SE", 2)) {
+			puts("Model: SanCloud BeagleBone Enhanced:\n");
+			base_dtb=BBE_BASE_DTB;
+			cape_universal=CAPE_UNIVERSAL_BBB;
+			name = "BBEN";
+		}
+		if (!strncmp(board_ti_get_rev(), "ME0", 3)) {
+			puts("Model: MENTOREL BeagleBone uSomIQ:\n");
+			virtual_video=NOT_POP;
+			virtual_audio=NOT_POP;
+			cape_universal=CAPE_UNIVERSAL_BBG;
+		}
+		if (!strncmp(board_ti_get_rev(), "NAD", 3)) {
+			puts("Model: Neuromeka BeagleBone Air:\n");
+			cape_universal=CAPE_UNIVERSAL;
+		}
+		if (!strncmp(board_ti_get_rev(), "OS0", 3)) {
+			puts("Model: Octavo Systems OSD3358-SM-RED:\n");
+			name = "OS00";
+			cape_universal=NOT_POP;
+			model=M_OS00;
+		}
+	}
+
+	if (board_is_bone()) {
+		puts("Model: BeagleBone:\n");
+		base_dtb=BB_BASE_DTB;
+		virtual_emmc=NOT_POP;
+		virtual_video=NOT_POP;
+		virtual_audio=NOT_POP;
+		virtual_wireless=NOT_POP;
+		virtual_adc=BBB_ADC;
+		cape_universal=CAPE_UNIVERSAL_BBB;
+		name = "A335BONE";
+	}
+
+	if (board_is_bbg1()) {
+		puts("Model: SeeedStudio BeagleBone Green:\n");
+		base_dtb=BBB_BASE_DTB;
+		virtual_emmc=BBB_EMMC;
+		virtual_video=NOT_POP;
+		virtual_audio=NOT_POP;
+		virtual_wireless=NOT_POP;
+		virtual_adc=BBB_ADC;
+		cape_universal=CAPE_UNIVERSAL_BBG;
+		name = "BBG1";
+		model=M_BBG1;
+	}
+
+	set_board_info_env(name);
+
+	i2c_set_bus_num(2);
+	strlcpy(cape_overlay_pass_to_kernel, "", 1);
+
+	for ( addr = CAPE_EEPROM_ADDR0; addr <= CAPE_EEPROM_ADDR3; addr++ ) {
+		if (i2c_probe(addr)) {
+			printf("BeagleBone: cape eeprom: i2c_probe: 0x%x:\n", addr);
+		} else {
+			/* read the eeprom using i2c */
+			if (i2c_read(addr, 0, 2, (uchar *)cape_header,
+				     sizeof(struct am335x_cape_eeprom_id))) {
+				puts("BeagleBone: cape eeprom: Could not read the EEPROM; something fundamentally"
+					" wrong on the I2C bus.\n");
+				return -EIO;
+			}
+
+			if (cape_header->header == 0xEE3355AA) {
+				strlcpy(cape_overlay, "/lib/firmware/", 14 + 1);
+				strlcpy(cape_overlay_pass_to_kernel, "", 2);
+				strlcpy(process_cape_part_number, "...............", 16 + 1);
+
+				strlcpy(process_cape_part_number, cape_header->part_number, 16 + 1);
+				printf("debug: process_cape_part_number:[%s]\n", process_cape_part_number);
+
+				//FIXME: some capes end with '.'
+				if ( process_cape_part_number[15] == 0x2E ) {
+					puts("debug: fixup, extra . in eeprom field\n");
+					process_cape_part_number[15] = 0x00;
+					if ( process_cape_part_number[14] == 0x2E ) {
+						process_cape_part_number[14] = 0x00;
+					}
+				}
+
+				//Find ending 0x00
+				puts("debug: process_cape_part_number:[");
+				end_part_number=16;
+				for ( int i=0; i <= 16; i++ ) {
+					if ( process_cape_part_number[i] == 0x00 ) {
+						end_part_number=i;
+						i=17;
+					} else {
+						printf("%x", process_cape_part_number[i]);
+					}
+				}
+				puts("]\n");
+
+				strncat(cape_overlay, process_cape_part_number, end_part_number);
+				//printf("debug: %s\n", cape_overlay);
+
+				strncat(cape_overlay, "-", 1);
+				//printf("debug: %s\n", cape_overlay);
+
+				strncat(cape_overlay, cape_header->version, 4);
+				//printf("debug: %s\n", cape_overlay);
+
+				strncat(cape_overlay, ".dtbo", 5);
+				//printf("debug: %s\n", cape_overlay);
+
+				unsigned long cape_overlay_hash = hash_string(cape_overlay);
+
+				printf("BeagleBone: cape eeprom: i2c_probe: 0x%x: %s [0x%lx]\n", addr, cape_overlay, cape_overlay_hash);
+
+				strncat(cape_overlay_pass_to_kernel, process_cape_part_number, end_part_number);
+				strncat(cape_overlay_pass_to_kernel, ",", 1);
+
+				switch(cape_overlay_hash) {
+					case 0x3c766f: /* /lib/firmware/BB-CAPE-DISP-CT4-00A0.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					case 0x24f51cf: /* /lib/firmware/BB-BONE-CAM-VVDN-00A0.dtbo */
+						virtual_emmc=PINS_TAKEN;
+						break;
+					case 0x4b0c13f: /* /lib/firmware/NL-AB-BBCL-00B0.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					case 0x74e7bbf: /* /lib/firmware/bb-justboom-dac-00A0.dtbo */
+						virtual_audio=PINS_TAKEN;
+						break;
+					case 0x93b574f: /* /lib/firmware/BB-GREEN-HDMI-00A0.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					case 0x9dcd73f: /* /lib/firmware/BB-BONE-NH10C-01-00A0.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					case 0xb1b7bbf: /* /lib/firmware/bb-justboom-amp-00A0.dtbo */
+						virtual_audio=PINS_TAKEN;
+						break;
+					//d15bb
+					case 0xd15b80f: /* /lib/firmware/DLPDLCR2000-00A0.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					case 0xd4c9eff: /* /lib/firmware/bb-justboom-digi-00A0.dtbo */
+						virtual_audio=PINS_TAKEN;
+						break;
+					case 0xe05061f: /* /lib/firmware/BBORG_DISPLAY70-00A2.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					case 0xe3f55df: /* /lib/firmware/BB-BONE-NH7C-01-A0.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					case 0xfc93c8f: /* /lib/firmware/BB-BONE-LCD7-01-00A3.dtbo */
+						virtual_video=PINS_TAKEN;
+						virtual_adc=PINS_TAKEN;
+						break;
+					//fe131
+					case 0xfe1313f: /* /lib/firmware/BB-BONE-4D5R-01-00A1.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					//fe132
+					case 0xfe1323f: /* /lib/firmware/BB-BONE-4D4R-01-00A1.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					case 0xfe1327f: /* /lib/firmware/BB-BONE-4D4N-01-00A1.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					case 0xfe132cf: /* /lib/firmware/BB-BONE-4D4C-01-00A1.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					//fe133
+					case 0xfe1337f: /* /lib/firmware/BB-BONE-4D7N-01-00A1.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					case 0xfe133cf: /* /lib/firmware/BB-BONE-4D7C-01-00A1.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					//fe135
+					case 0xfe1357f: /* /lib/firmware/BB-BONE-4D5N-01-00A1.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					case 0xfe135cf: /* /lib/firmware/BB-BONE-4D5C-01-00A1.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					//fe137
+					case 0xfe1373f: /* /lib/firmware/BB-BONE-4D7R-01-00A1.dtbo */
+						virtual_video=PINS_TAKEN;
+						break;
+					case 0xfe93c1f: /* /lib/firmware/BB-BONE-LCD4-01-00A1.dtbo */
+						virtual_video=PINS_TAKEN;
+						virtual_adc=PINS_TAKEN;
+						break;
+				}
+
+				switch(addr) {
+					case CAPE_EEPROM_ADDR0:
+						env_set("uboot_overlay_addr0", cape_overlay);
+						env_set("uboot_detected_capes_addr0", cape_overlay_pass_to_kernel);
+						break;
+					case CAPE_EEPROM_ADDR1:
+						env_set("uboot_overlay_addr1", cape_overlay);
+						env_set("uboot_detected_capes_addr1", cape_overlay_pass_to_kernel);
+						break;
+					case CAPE_EEPROM_ADDR2:
+						env_set("uboot_overlay_addr2", cape_overlay);
+						env_set("uboot_detected_capes_addr2", cape_overlay_pass_to_kernel);
+						break;
+					case CAPE_EEPROM_ADDR3:
+						env_set("uboot_overlay_addr3", cape_overlay);
+						env_set("uboot_detected_capes_addr3", cape_overlay_pass_to_kernel);
+						break;
+				}
+				env_set("uboot_detected_capes", "1");
+			} else {
+				printf("BeagleBone: found invalid cape eeprom: i2c_probe: 0x%x:\n", addr);
+			}
+		}
+	}//for
+
+	switch(base_dtb) {
+		case BB_BASE_DTB:
+			env_set("uboot_base_dtb_univ", "am335x-bone-uboot-univ.dtb");
+			env_set("uboot_base_dtb", "am335x-bone.dtb");
+			env_set("uboot_try_cape_universal", "1");
+			break;
+		case BBB_BASE_DTB:
+			env_set("uboot_base_dtb_univ", "am335x-boneblack-uboot-univ.dtb");
+			env_set("uboot_base_dtb", "am335x-boneblack-uboot.dtb");
+			env_set("uboot_try_cape_universal", "1");
+			break;
+		case BBGW_BASE_DTB:
+			//gpio-hogs and cape-universal dont mesh very well on bootup...
+			env_set("uboot_base_dtb_univ", "am335x-bonegreen-wireless-uboot-univ.dtb");
+			env_set("uboot_base_dtb", "am335x-boneblack-uboot.dtb");
+			env_set("uboot_try_cape_universal", "1");
+			break;
+		case BBE_BASE_DTB:
+			env_set("uboot_base_dtb_univ", "am335x-sancloud-bbe-uboot-univ.dtb");
+			env_set("uboot_base_dtb", "am335x-sancloud-bbe-uboot.dtb");
+			env_set("uboot_try_cape_universal", "1");
+			break;
+		case BBBL_BASE_DTB:
+			env_set("uboot_base_dtb_univ", "am335x-boneblue.dtb");
+			break;
+	}
+
+	if (virtual_emmc == BBB_EMMC) {
+		env_set("uboot_emmc", "/lib/firmware/BB-BONE-eMMC1-01-00A0.dtbo");
+	}
+
+	switch(virtual_video) {
+		case BBB_TDA998X_AUDIO:
+			if (virtual_audio == PINS_TAKEN) {
+				env_set("uboot_video", "/lib/firmware/BB-NHDMI-TDA998x-00A0.dtbo");
+				env_set("uboot_video_naudio", "/lib/firmware/BB-NHDMI-TDA998x-00A0.dtbo");
+			} else {
+				env_set("uboot_video", "/lib/firmware/BB-HDMI-TDA998x-00A0.dtbo");
+				env_set("uboot_video_naudio", "/lib/firmware/BB-NHDMI-TDA998x-00A0.dtbo");
+			}
+			break;
+		case BBB_TDA998X_NAUDIO:
+			env_set("uboot_video", "/lib/firmware/BB-NHDMI-TDA998x-00A0.dtbo");
+			env_set("uboot_video_naudio", "/lib/firmware/BB-NHDMI-TDA998x-00A0.dtbo");
+			break;
+		case BBB_ADV7511_AUDIO:
+			if (virtual_audio == PINS_TAKEN) {
+				env_set("uboot_video", "/lib/firmware/BB-NHDMI-ADV7511-00A0.dtbo");
+				env_set("uboot_video_naudio", "/lib/firmware/BB-NHDMI-ADV7511-00A0.dtbo");
+			} else {
+				env_set("uboot_video", "/lib/firmware/BB-HDMI-ADV7511-00A0.dtbo");
+				env_set("uboot_video_naudio", "/lib/firmware/BB-NHDMI-ADV7511-00A0.dtbo");
+			}
+			break;
+		case BBB_ADV7511_NAUDIO:
+			env_set("uboot_video", "/lib/firmware/BB-NHDMI-ADV7511-00A0.dtbo");
+			env_set("uboot_video_naudio", "/lib/firmware/BB-NHDMI-ADV7511-00A0.dtbo");
+			break;
+	}
+
+	switch(virtual_wireless) {
+		case BBBW_WL1835:
+			env_set("uboot_wireless", "/lib/firmware/BB-BBBW-WL1835-00A0.dtbo");
+			break;
+		case BBGW_WL1835:
+			env_set("uboot_wireless", "/lib/firmware/BB-BBGW-WL1835-00A0.dtbo");
+			break;
+	}
+
+	switch(virtual_adc) {
+		case BBB_ADC:
+			env_set("uboot_adc", "/lib/firmware/BB-ADC-00A0.dtbo");
+			break;
+	}
+
+	switch(model) {
+		case M_BBG1:
+			env_set("uboot_model", "/lib/firmware/M-BB-BBG-00A0.dtbo");
+			break;
+		case M_OS00:
+			env_set("uboot_model", "/lib/firmware/M-BB-OSD3358-SM-RED-00A0.dtbo");
+			break;
+	}
+
+	switch(cape_universal) {
+		case CAPE_UNIVERSAL_BBB:
+			env_set("uboot_cape_universal_bbb", "1");
+			break;
+		case CAPE_UNIVERSAL_BBG:
+			env_set("uboot_cape_universal_bbg", "1");
+			break;
+		case CAPE_UNIVERSAL_BBGW:
+			env_set("uboot_cape_universal_bbgw", "1");
+			break;
+	}
+
+	i2c_set_bus_num(0);
+	return 0;
+}
+
+void do_cape_detect(void)
+{
+	struct am335x_cape_eeprom_id cape_header;
+
+#ifndef CONFIG_DM_I2C
+	i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED2, CONFIG_SYS_OMAP24_I2C_SLAVE2);
+#endif
+	probe_cape_eeprom(&cape_header);
+}
+
+#ifndef CONFIG_DM_SERIAL
+struct serial_device *default_serial_console(void)
+{
+	if (board_is_icev2())
+		return &eserial4_device;
+	else if (board_is_beaglelogic())
+		return &eserial5_device;
+	else
+		return &eserial1_device;
+}
+#endif
+
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+static const struct ddr_data ddr2_data = {
+	.datardsratio0 = MT47H128M16RT25E_RD_DQS,
+	.datafwsratio0 = MT47H128M16RT25E_PHY_FIFO_WE,
+	.datawrsratio0 = MT47H128M16RT25E_PHY_WR_DATA,
+};
+
+static const struct cmd_control ddr2_cmd_ctrl_data = {
+	.cmd0csratio = MT47H128M16RT25E_RATIO,
+
+	.cmd1csratio = MT47H128M16RT25E_RATIO,
+
+	.cmd2csratio = MT47H128M16RT25E_RATIO,
+};
+
+static const struct emif_regs ddr2_emif_reg_data = {
+	.sdram_config = MT47H128M16RT25E_EMIF_SDCFG,
+	.ref_ctrl = MT47H128M16RT25E_EMIF_SDREF,
+	.sdram_tim1 = MT47H128M16RT25E_EMIF_TIM1,
+	.sdram_tim2 = MT47H128M16RT25E_EMIF_TIM2,
+	.sdram_tim3 = MT47H128M16RT25E_EMIF_TIM3,
+	.emif_ddr_phy_ctlr_1 = MT47H128M16RT25E_EMIF_READ_LATENCY,
+};
+
+static const struct emif_regs ddr2_evm_emif_reg_data = {
+	.sdram_config = MT47H128M16RT25E_EMIF_SDCFG,
+	.ref_ctrl = MT47H128M16RT25E_EMIF_SDREF,
+	.sdram_tim1 = MT47H128M16RT25E_EMIF_TIM1,
+	.sdram_tim2 = MT47H128M16RT25E_EMIF_TIM2,
+	.sdram_tim3 = MT47H128M16RT25E_EMIF_TIM3,
+	.ocp_config = EMIF_OCP_CONFIG_AM335X_EVM,
+	.emif_ddr_phy_ctlr_1 = MT47H128M16RT25E_EMIF_READ_LATENCY,
+};
+
+static const struct ddr_data ddr3_data = {
+	.datardsratio0 = MT41J128MJT125_RD_DQS,
+	.datawdsratio0 = MT41J128MJT125_WR_DQS,
+	.datafwsratio0 = MT41J128MJT125_PHY_FIFO_WE,
+	.datawrsratio0 = MT41J128MJT125_PHY_WR_DATA,
+};
+
+static const struct ddr_data ddr3_beagleblack_data = {
+	.datardsratio0 = MT41K256M16HA125E_RD_DQS,
+	.datawdsratio0 = MT41K256M16HA125E_WR_DQS,
+	.datafwsratio0 = MT41K256M16HA125E_PHY_FIFO_WE,
+	.datawrsratio0 = MT41K256M16HA125E_PHY_WR_DATA,
+};
+
+static const struct ddr_data ddr3_evm_data = {
+	.datardsratio0 = MT41J512M8RH125_RD_DQS,
+	.datawdsratio0 = MT41J512M8RH125_WR_DQS,
+	.datafwsratio0 = MT41J512M8RH125_PHY_FIFO_WE,
+	.datawrsratio0 = MT41J512M8RH125_PHY_WR_DATA,
+};
+
+static const struct ddr_data ddr3_icev2_data = {
+	.datardsratio0 = MT41J128MJT125_RD_DQS_400MHz,
+	.datawdsratio0 = MT41J128MJT125_WR_DQS_400MHz,
+	.datafwsratio0 = MT41J128MJT125_PHY_FIFO_WE_400MHz,
+	.datawrsratio0 = MT41J128MJT125_PHY_WR_DATA_400MHz,
+};
+
+static const struct cmd_control ddr3_cmd_ctrl_data = {
+	.cmd0csratio = MT41J128MJT125_RATIO,
+	.cmd0iclkout = MT41J128MJT125_INVERT_CLKOUT,
+
+	.cmd1csratio = MT41J128MJT125_RATIO,
+	.cmd1iclkout = MT41J128MJT125_INVERT_CLKOUT,
+
+	.cmd2csratio = MT41J128MJT125_RATIO,
+	.cmd2iclkout = MT41J128MJT125_INVERT_CLKOUT,
+};
+
+static const struct cmd_control ddr3_beagleblack_cmd_ctrl_data = {
+	.cmd0csratio = MT41K256M16HA125E_RATIO,
+	.cmd0iclkout = MT41K256M16HA125E_INVERT_CLKOUT,
+
+	.cmd1csratio = MT41K256M16HA125E_RATIO,
+	.cmd1iclkout = MT41K256M16HA125E_INVERT_CLKOUT,
+
+	.cmd2csratio = MT41K256M16HA125E_RATIO,
+	.cmd2iclkout = MT41K256M16HA125E_INVERT_CLKOUT,
+};
+
+static const struct cmd_control ddr3_evm_cmd_ctrl_data = {
+	.cmd0csratio = MT41J512M8RH125_RATIO,
+	.cmd0iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+
+	.cmd1csratio = MT41J512M8RH125_RATIO,
+	.cmd1iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+
+	.cmd2csratio = MT41J512M8RH125_RATIO,
+	.cmd2iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+};
+
+static const struct cmd_control ddr3_icev2_cmd_ctrl_data = {
+	.cmd0csratio = MT41J128MJT125_RATIO_400MHz,
+	.cmd0iclkout = MT41J128MJT125_INVERT_CLKOUT_400MHz,
+
+	.cmd1csratio = MT41J128MJT125_RATIO_400MHz,
+	.cmd1iclkout = MT41J128MJT125_INVERT_CLKOUT_400MHz,
+
+	.cmd2csratio = MT41J128MJT125_RATIO_400MHz,
+	.cmd2iclkout = MT41J128MJT125_INVERT_CLKOUT_400MHz,
+};
+
+static struct emif_regs ddr3_emif_reg_data = {
+	.sdram_config = MT41J128MJT125_EMIF_SDCFG,
+	.ref_ctrl = MT41J128MJT125_EMIF_SDREF,
+	.sdram_tim1 = MT41J128MJT125_EMIF_TIM1,
+	.sdram_tim2 = MT41J128MJT125_EMIF_TIM2,
+	.sdram_tim3 = MT41J128MJT125_EMIF_TIM3,
+	.zq_config = MT41J128MJT125_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1 = MT41J128MJT125_EMIF_READ_LATENCY |
+				PHY_EN_DYN_PWRDN,
+};
+
+static struct emif_regs ddr3_beagleblack_emif_reg_data = {
+	.sdram_config = MT41K256M16HA125E_EMIF_SDCFG,
+	.ref_ctrl = MT41K256M16HA125E_EMIF_SDREF,
+	.sdram_tim1 = MT41K256M16HA125E_EMIF_TIM1,
+	.sdram_tim2 = MT41K256M16HA125E_EMIF_TIM2,
+	.sdram_tim3 = MT41K256M16HA125E_EMIF_TIM3,
+	.ocp_config = EMIF_OCP_CONFIG_BEAGLEBONE_BLACK,
+	.zq_config = MT41K256M16HA125E_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1 = MT41K256M16HA125E_EMIF_READ_LATENCY,
+};
+
+static struct emif_regs ddr3_evm_emif_reg_data = {
+	.sdram_config = MT41J512M8RH125_EMIF_SDCFG,
+	.ref_ctrl = MT41J512M8RH125_EMIF_SDREF,
+	.sdram_tim1 = MT41J512M8RH125_EMIF_TIM1,
+	.sdram_tim2 = MT41J512M8RH125_EMIF_TIM2,
+	.sdram_tim3 = MT41J512M8RH125_EMIF_TIM3,
+	.ocp_config = EMIF_OCP_CONFIG_AM335X_EVM,
+	.zq_config = MT41J512M8RH125_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1 = MT41J512M8RH125_EMIF_READ_LATENCY |
+				PHY_EN_DYN_PWRDN,
+};
+
+static struct emif_regs ddr3_icev2_emif_reg_data = {
+	.sdram_config = MT41J128MJT125_EMIF_SDCFG_400MHz,
+	.ref_ctrl = MT41J128MJT125_EMIF_SDREF_400MHz,
+	.sdram_tim1 = MT41J128MJT125_EMIF_TIM1_400MHz,
+	.sdram_tim2 = MT41J128MJT125_EMIF_TIM2_400MHz,
+	.sdram_tim3 = MT41J128MJT125_EMIF_TIM3_400MHz,
+	.zq_config = MT41J128MJT125_ZQ_CFG_400MHz,
+	.emif_ddr_phy_ctlr_1 = MT41J128MJT125_EMIF_READ_LATENCY_400MHz |
+				PHY_EN_DYN_PWRDN,
+};
+
+#ifdef CONFIG_SPL_OS_BOOT
+int spl_start_uboot(void)
+{
+	printf("preitinger: spl_start_uboot start\n");
+#ifdef CONFIG_SPL_SERIAL_SUPPORT
+	printf("preitinger: in ifdef 1\n");
+	/* break into full u-boot on 'c' */
+	if (serial_tstc() && serial_getc() == 'c')
+		return 1;
+#endif
+
+#ifdef CONFIG_SPL_ENV_SUPPORT
+	printf("preitinger: in ifdef 2\n");
+	env_init();
+	env_load();
+	int preitinger_res = env_get_yesno("boot_os");
+	if (env_get_yesno("boot_os") != 1) {
+		printf("preitinger: return 1 wegen boot_os?! - wert: %d\n", preitinger_res);
+		return 1;
+}
+#endif
+	printf("preitinger:spl_start_uboot returning 0\n");
+	return 0;
+}
+#endif
+
+const struct dpll_params *get_dpll_ddr_params(void)
+{
+	int ind = get_sys_clk_index();
+
+	if (board_is_evm_sk())
+		return &dpll_ddr3_303MHz[ind];
+	else if (board_is_pb() || board_is_bone_lt() || board_is_icev2() || board_is_beaglelogic())
+		return &dpll_ddr3_400MHz[ind];
+	else if (board_is_evm_15_or_later())
+		return &dpll_ddr3_303MHz[ind];
+	else
+		return &dpll_ddr2_266MHz[ind];
+}
+
+static u8 bone_not_connected_to_ac_power(void)
+{
+	if (board_is_bone()) {
+		uchar pmic_status_reg;
+		if (tps65217_reg_read(TPS65217_STATUS,
+				      &pmic_status_reg))
+			return 1;
+		if (!(pmic_status_reg & TPS65217_PWR_SRC_AC_BITMASK)) {
+			puts("No AC power, switching to default OPP\n");
+			return 1;
+		}
+	}
+	return 0;
+}
+
+const struct dpll_params *get_dpll_mpu_params(void)
+{
+	int ind = get_sys_clk_index();
+	int freq = am335x_get_efuse_mpu_max_freq(cdev);
+
+	if (bone_not_connected_to_ac_power())
+		freq = MPUPLL_M_600;
+
+	if (board_is_pb() || board_is_bone_lt() || board_is_beaglelogic())
+		freq = MPUPLL_M_1000;
+
+	switch (freq) {
+	case MPUPLL_M_1000:
+		return &dpll_mpu_opp[ind][5];
+	case MPUPLL_M_800:
+		return &dpll_mpu_opp[ind][4];
+	case MPUPLL_M_720:
+		return &dpll_mpu_opp[ind][3];
+	case MPUPLL_M_600:
+		return &dpll_mpu_opp[ind][2];
+	case MPUPLL_M_500:
+		return &dpll_mpu_opp100;
+	case MPUPLL_M_300:
+		return &dpll_mpu_opp[ind][0];
+	}
+
+	return &dpll_mpu_opp[ind][0];
+}
+
+static void scale_vcores_bone(int freq)
+{
+	int usb_cur_lim, mpu_vdd;
+
+	/*
+	 * Only perform PMIC configurations if board rev > A1
+	 * on Beaglebone White
+	 */
+	if (board_is_bone() && !strncmp(board_ti_get_rev(), "00A1", 4))
+		return;
+
+#ifndef CONFIG_DM_I2C
+	if (i2c_probe(TPS65217_CHIP_PM))
+		return;
+#else
+	if (power_tps65217_init(0))
+		return;
+#endif
+
+
+	/*
+	 * On Beaglebone White we need to ensure we have AC power
+	 * before increasing the frequency.
+	 */
+	if (bone_not_connected_to_ac_power())
+		freq = MPUPLL_M_600;
+
+	/*
+	 * Override what we have detected since we know if we have
+	 * a Beaglebone Black it supports 1GHz.
+	 */
+	if (board_is_pb() || board_is_bone_lt() || board_is_beaglelogic())
+		freq = MPUPLL_M_1000;
+
+	switch (freq) {
+	case MPUPLL_M_1000:
+		mpu_vdd = TPS65217_DCDC_VOLT_SEL_1325MV;
+		usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1800MA;
+		break;
+	case MPUPLL_M_800:
+		mpu_vdd = TPS65217_DCDC_VOLT_SEL_1275MV;
+		usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1300MA;
+		break;
+	case MPUPLL_M_720:
+		mpu_vdd = TPS65217_DCDC_VOLT_SEL_1200MV;
+		usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1300MA;
+		break;
+	case MPUPLL_M_600:
+	case MPUPLL_M_500:
+	case MPUPLL_M_300:
+	default:
+		mpu_vdd = TPS65217_DCDC_VOLT_SEL_1100MV;
+		usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1300MA;
+		break;
+	}
+
+	if (tps65217_reg_write(TPS65217_PROT_LEVEL_NONE,
+			       TPS65217_POWER_PATH,
+			       usb_cur_lim,
+			       TPS65217_USB_INPUT_CUR_LIMIT_MASK))
+		puts("tps65217_reg_write failure\n");
+
+	/* Set DCDC3 (CORE) voltage to 1.10V */
+	if (tps65217_voltage_update(TPS65217_DEFDCDC3,
+				    TPS65217_DCDC_VOLT_SEL_1100MV)) {
+		puts("tps65217_voltage_update failure\n");
+		return;
+	}
+
+	/* Set DCDC2 (MPU) voltage */
+	if (tps65217_voltage_update(TPS65217_DEFDCDC2, mpu_vdd)) {
+		puts("tps65217_voltage_update failure\n");
+		return;
+	}
+
+	/*
+	 * Set LDO3, LDO4 output voltage to 3.3V for Beaglebone.
+	 * Set LDO3 to 1.8V and LDO4 to 3.3V for Beaglebone Black.
+	 */
+	if (board_is_bone()) {
+		if (tps65217_reg_write(TPS65217_PROT_LEVEL_2,
+				       TPS65217_DEFLS1,
+				       TPS65217_LDO_VOLTAGE_OUT_3_3,
+				       TPS65217_LDO_MASK))
+			puts("tps65217_reg_write failure\n");
+	} else {
+		if (tps65217_reg_write(TPS65217_PROT_LEVEL_2,
+				       TPS65217_DEFLS1,
+				       TPS65217_LDO_VOLTAGE_OUT_1_8,
+				       TPS65217_LDO_MASK))
+			puts("tps65217_reg_write failure\n");
+	}
+
+	if (tps65217_reg_write(TPS65217_PROT_LEVEL_2,
+			       TPS65217_DEFLS2,
+			       TPS65217_LDO_VOLTAGE_OUT_3_3,
+			       TPS65217_LDO_MASK))
+		puts("tps65217_reg_write failure\n");
+}
+
+void scale_vcores_generic(int freq)
+{
+	int sil_rev, mpu_vdd;
+
+	/*
+	 * The GP EVM, IDK and EVM SK use a TPS65910 PMIC.  For all
+	 * MPU frequencies we support we use a CORE voltage of
+	 * 1.10V.  For MPU voltage we need to switch based on
+	 * the frequency we are running at.
+	 */
+#ifndef CONFIG_DM_I2C
+	if (i2c_probe(TPS65910_CTRL_I2C_ADDR))
+		return;
+#else
+	if (power_tps65910_init(0))
+		return;
+#endif
+	/*
+	 * Depending on MPU clock and PG we will need a different
+	 * VDD to drive at that speed.
+	 */
+	sil_rev = readl(&cdev->deviceid) >> 28;
+	mpu_vdd = am335x_get_tps65910_mpu_vdd(sil_rev, freq);
+
+	/* Tell the TPS65910 to use i2c */
+	tps65910_set_i2c_control();
+
+	/* First update MPU voltage. */
+	if (tps65910_voltage_update(MPU, mpu_vdd))
+		return;
+
+	/* Second, update the CORE voltage. */
+	if (tps65910_voltage_update(CORE, TPS65910_OP_REG_SEL_1_1_0))
+		return;
+
+}
+
+void gpi2c_init(void)
+{
+	/* When needed to be invoked prior to BSS initialization */
+	static bool first_time = true;
+
+	if (first_time) {
+		enable_i2c0_pin_mux();
+#ifndef CONFIG_DM_I2C
+		i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED,
+			 CONFIG_SYS_OMAP24_I2C_SLAVE);
+#endif
+		first_time = false;
+	}
+}
+
+void scale_vcores(void)
+{
+	int freq;
+
+	gpi2c_init();
+	freq = am335x_get_efuse_mpu_max_freq(cdev);
+
+	if (board_is_beaglebonex())
+		scale_vcores_bone(freq);
+	else
+		scale_vcores_generic(freq);
+}
+
+void set_uart_mux_conf(void)
+{
+#if CONFIG_CONS_INDEX == 1
+	if (board_is_beaglelogic())
+		enable_uart4_pin_mux();
+	else
+		enable_uart0_pin_mux();
+
+#elif CONFIG_CONS_INDEX == 2
+	enable_uart1_pin_mux();
+#elif CONFIG_CONS_INDEX == 3
+	enable_uart2_pin_mux();
+#elif CONFIG_CONS_INDEX == 4
+	enable_uart3_pin_mux();
+#elif CONFIG_CONS_INDEX == 5
+	enable_uart4_pin_mux();
+#elif CONFIG_CONS_INDEX == 6
+	enable_uart5_pin_mux();
+#endif
+}
+
+void set_mux_conf_regs(void)
+{
+	enable_board_pin_mux();
+}
+
+const struct ctrl_ioregs ioregs_evmsk = {
+	.cm0ioctl		= MT41J128MJT125_IOCTRL_VALUE,
+	.cm1ioctl		= MT41J128MJT125_IOCTRL_VALUE,
+	.cm2ioctl		= MT41J128MJT125_IOCTRL_VALUE,
+	.dt0ioctl		= MT41J128MJT125_IOCTRL_VALUE,
+	.dt1ioctl		= MT41J128MJT125_IOCTRL_VALUE,
+};
+
+const struct ctrl_ioregs ioregs_bonelt = {
+	.cm0ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+	.cm1ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+	.cm2ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+	.dt0ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+	.dt1ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+};
+
+const struct ctrl_ioregs ioregs_evm15 = {
+	.cm0ioctl		= MT41J512M8RH125_IOCTRL_VALUE,
+	.cm1ioctl		= MT41J512M8RH125_IOCTRL_VALUE,
+	.cm2ioctl		= MT41J512M8RH125_IOCTRL_VALUE,
+	.dt0ioctl		= MT41J512M8RH125_IOCTRL_VALUE,
+	.dt1ioctl		= MT41J512M8RH125_IOCTRL_VALUE,
+};
+
+const struct ctrl_ioregs ioregs = {
+	.cm0ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.cm1ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.cm2ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.dt0ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.dt1ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+};
+
+void sdram_init(void)
+{
+	if (board_is_evm_sk()) {
+		/*
+		 * EVM SK 1.2A and later use gpio0_7 to enable DDR3.
+		 * This is safe enough to do on older revs.
+		 */
+		gpio_request(GPIO_DDR_VTT_EN, "ddr_vtt_en");
+		gpio_direction_output(GPIO_DDR_VTT_EN, 1);
+	}
+
+	if (board_is_icev2()) {
+		gpio_request(ICE_GPIO_DDR_VTT_EN, "ddr_vtt_en");
+		gpio_direction_output(ICE_GPIO_DDR_VTT_EN, 1);
+	}
+
+	if (board_is_evm_sk())
+		config_ddr(303, &ioregs_evmsk, &ddr3_data,
+			   &ddr3_cmd_ctrl_data, &ddr3_emif_reg_data, 0);
+	else if (board_is_pb() || board_is_bone_lt() || board_is_beaglelogic())
+		config_ddr(400, &ioregs_bonelt,
+			   &ddr3_beagleblack_data,
+			   &ddr3_beagleblack_cmd_ctrl_data,
+			   &ddr3_beagleblack_emif_reg_data, 0);
+	else if (board_is_evm_15_or_later())
+		config_ddr(303, &ioregs_evm15, &ddr3_evm_data,
+			   &ddr3_evm_cmd_ctrl_data, &ddr3_evm_emif_reg_data, 0);
+	else if (board_is_icev2())
+		config_ddr(400, &ioregs_evmsk, &ddr3_icev2_data,
+			   &ddr3_icev2_cmd_ctrl_data, &ddr3_icev2_emif_reg_data,
+			   0);
+	else if (board_is_gp_evm())
+		config_ddr(266, &ioregs, &ddr2_data,
+			   &ddr2_cmd_ctrl_data, &ddr2_evm_emif_reg_data, 0);
+	else
+		config_ddr(266, &ioregs, &ddr2_data,
+			   &ddr2_cmd_ctrl_data, &ddr2_emif_reg_data, 0);
+}
+#endif
+
+#if defined(CONFIG_CLOCK_SYNTHESIZER) && (!defined(CONFIG_SPL_BUILD) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD)))
+static void request_and_set_gpio(int gpio, char *name, int val)
+{
+	int ret;
+
+	ret = gpio_request(gpio, name);
+	if (ret < 0) {
+		printf("%s: Unable to request %s\n", __func__, name);
+		return;
+	}
+
+	ret = gpio_direction_output(gpio, 0);
+	if (ret < 0) {
+		printf("%s: Unable to set %s  as output\n", __func__, name);
+		goto err_free_gpio;
+	}
+
+	gpio_set_value(gpio, val);
+
+	return;
+
+err_free_gpio:
+	gpio_free(gpio);
+}
+
+#define REQUEST_AND_SET_GPIO(N)	request_and_set_gpio(N, #N, 1);
+#define REQUEST_AND_CLR_GPIO(N)	request_and_set_gpio(N, #N, 0);
+
+/**
+ * RMII mode on ICEv2 board needs 50MHz clock. Given the clock
+ * synthesizer With a capacitor of 18pF, and 25MHz input clock cycle
+ * PLL1 gives an output of 100MHz. So, configuring the div2/3 as 2 to
+ * give 50MHz output for Eth0 and 1.
+ */
+static struct clk_synth cdce913_data = {
+	.id = 0x81,
+	.capacitor = 0x90,
+	.mux = 0x6d,
+	.pdiv2 = 0x2,
+	.pdiv3 = 0x2,
+};
+#endif
+
+#if defined(CONFIG_OF_BOARD_SETUP) && defined(CONFIG_OF_CONTROL) && \
+	defined(CONFIG_DM_ETH) && defined(CONFIG_DRIVER_TI_CPSW)
+
+#define MAX_CPSW_SLAVES	2
+
+/* At the moment, we do not want to stop booting for any failures here */
+int ft_board_setup(void *fdt, bd_t *bd)
+{
+	const char *slave_path, *enet_name;
+	int enetnode, slavenode, phynode;
+	struct udevice *ethdev;
+	char alias[16];
+	u32 phy_id[2];
+	int phy_addr;
+	int i, ret;
+
+	/* phy address fixup needed only on beagle bone family */
+	if (!board_is_beaglebonex())
+		goto done;
+
+	/* This needs more testing, (on old kernels/etc..) */
+	if (board_is_beaglebonex())
+		goto done;
+
+	for (i = 0; i < MAX_CPSW_SLAVES; i++) {
+		sprintf(alias, "ethernet%d", i);
+
+		slave_path = fdt_get_alias(fdt, alias);
+		if (!slave_path)
+			continue;
+
+		slavenode = fdt_path_offset(fdt, slave_path);
+		if (slavenode < 0)
+			continue;
+
+		enetnode = fdt_parent_offset(fdt, slavenode);
+		enet_name = fdt_get_name(fdt, enetnode, NULL);
+
+		ethdev = eth_get_dev_by_name(enet_name);
+		if (!ethdev)
+			continue;
+
+		phy_addr = cpsw_get_slave_phy_addr(ethdev, i);
+
+		/* check for phy_id as well as phy-handle properties */
+		ret = fdtdec_get_int_array_count(fdt, slavenode, "phy_id",
+						 phy_id, 2);
+		if (ret == 2) {
+			if (phy_id[1] != phy_addr) {
+				printf("fixing up phy_id for %s, old: %d, new: %d\n",
+				       alias, phy_id[1], phy_addr);
+
+				phy_id[0] = cpu_to_fdt32(phy_id[0]);
+				phy_id[1] = cpu_to_fdt32(phy_addr);
+				do_fixup_by_path(fdt, slave_path, "phy_id",
+						 phy_id, sizeof(phy_id), 0);
+			}
+		} else {
+			phynode = fdtdec_lookup_phandle(fdt, slavenode,
+							"phy-handle");
+			if (phynode < 0)
+				continue;
+
+			ret = fdtdec_get_int(fdt, phynode, "reg", -ENOENT);
+			if (ret < 0)
+				continue;
+
+			if (ret != phy_addr) {
+				printf("fixing up phy-handle for %s, old: %d, new: %d\n",
+				       alias, ret, phy_addr);
+
+				fdt_setprop_u32(fdt, phynode, "reg",
+						cpu_to_fdt32(phy_addr));
+			}
+		}
+	}
+
+done:
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_SPL_AM33XX_ENABLE_RTC32K_OSC)
+void rtc32k_enable(void)
+{
+	struct davinci_rtc *rtc = (struct davinci_rtc *)RTC_BASE;
+
+	/*
+	 * Unlock the RTC's registers.  For more details please see the
+	 * RTC_SS section of the TRM.  In order to unlock we need to
+	 * write these specific values (keys) in this order.
+	 */
+	writel(RTC_KICK0R_WE, &rtc->kick0r);
+	writel(RTC_KICK1R_WE, &rtc->kick1r);
+
+	if (board_is_pb() || board_is_blue()) {
+		/* 6: EN_32KCLK */
+		/* 3: SEL_32KCLK_SRC 0: internal, 1: external */
+		writel((0 << 3) | (1 << 6), &rtc->osc);
+	} else {
+		/* Enable the RTC 32K OSC by setting bits 3 and 6. */
+		writel((1 << 3) | (1 << 6), &rtc->osc);
+	}
+}
+#endif
+
+/*
+ * Basic board specific setup.  Pinmux has been handled already.
+ */
+int board_init(void)
+{
+	u32 sys_reboot, sys_rtc_osc;
+
+	sys_reboot = readl(PRM_RSTST);
+	if (sys_reboot & (1 << 9))
+		puts("Reset Source: IcePick reset has occurred.\n");
+
+	if (sys_reboot & (1 << 5))
+		puts("Reset Source: Global external warm reset has occurred.\n");
+
+	if (sys_reboot & (1 << 4))
+		puts("Reset Source: watchdog reset has occurred.\n");
+
+	if (sys_reboot & (1 << 1))
+		puts("Reset Source: Global warm SW reset has occurred.\n");
+
+	if (sys_reboot & (1 << 0))
+		puts("Reset Source: Power-on reset has occurred.\n");
+
+	sys_rtc_osc = readl(RTC_OSC);
+	if (sys_rtc_osc & (1 << 3)) {
+		puts("RTC 32KCLK Source: External.\n");
+	} else {
+		puts("RTC 32KCLK Source: Internal.\n");
+	}
+
+#if defined(CONFIG_HW_WATCHDOG)
+	hw_watchdog_init();
+#endif
+
+	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+#if defined(CONFIG_NOR) || defined(CONFIG_NAND)
+	gpmc_init();
+#endif
+
+#if defined(CONFIG_CLOCK_SYNTHESIZER) && (!defined(CONFIG_SPL_BUILD) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD)))
+	if (board_is_icev2()) {
+		int rv;
+		u32 reg;
+
+		REQUEST_AND_SET_GPIO(GPIO_PR1_MII_CTRL);
+		/* Make J19 status available on GPIO1_26 */
+		REQUEST_AND_CLR_GPIO(GPIO_MUX_MII_CTRL);
+
+		REQUEST_AND_SET_GPIO(GPIO_FET_SWITCH_CTRL);
+		/*
+		 * Both ports can be set as RMII-CPSW or MII-PRU-ETH using
+		 * jumpers near the port. Read the jumper value and set
+		 * the pinmux, external mux and PHY clock accordingly.
+		 * As jumper line is overridden by PHY RX_DV pin immediately
+		 * after bootstrap (power-up/reset), we need to sample
+		 * it during PHY reset using GPIO rising edge detection.
+		 */
+		REQUEST_AND_SET_GPIO(GPIO_PHY_RESET);
+		/* Enable rising edge IRQ on GPIO0_11 and GPIO 1_26 */
+		reg = readl(GPIO0_RISINGDETECT) | BIT(11);
+		writel(reg, GPIO0_RISINGDETECT);
+		reg = readl(GPIO1_RISINGDETECT) | BIT(26);
+		writel(reg, GPIO1_RISINGDETECT);
+		/* Reset PHYs to capture the Jumper setting */
+		gpio_set_value(GPIO_PHY_RESET, 0);
+		udelay(2);	/* PHY datasheet states 1uS min. */
+		gpio_set_value(GPIO_PHY_RESET, 1);
+
+		reg = readl(GPIO0_IRQSTATUSRAW) & BIT(11);
+		if (reg) {
+			writel(reg, GPIO0_IRQSTATUS1); /* clear irq */
+			/* RMII mode */
+			printf("ETH0, CPSW\n");
+		} else {
+			/* MII mode */
+			printf("ETH0, PRU\n");
+			cdce913_data.pdiv3 = 4;	/* 25MHz PHY clk */
+		}
+
+		reg = readl(GPIO1_IRQSTATUSRAW) & BIT(26);
+		if (reg) {
+			writel(reg, GPIO1_IRQSTATUS1); /* clear irq */
+			/* RMII mode */
+			printf("ETH1, CPSW\n");
+			gpio_set_value(GPIO_MUX_MII_CTRL, 1);
+		} else {
+			/* MII mode */
+			printf("ETH1, PRU\n");
+			cdce913_data.pdiv2 = 4;	/* 25MHz PHY clk */
+		}
+
+		/* disable rising edge IRQs */
+		reg = readl(GPIO0_RISINGDETECT) & ~BIT(11);
+		writel(reg, GPIO0_RISINGDETECT);
+		reg = readl(GPIO1_RISINGDETECT) & ~BIT(26);
+		writel(reg, GPIO1_RISINGDETECT);
+
+		rv = setup_clock_synthesizer(&cdce913_data);
+		if (rv) {
+			printf("Clock synthesizer setup failed %d\n", rv);
+			return rv;
+		}
+
+		/* reset PHYs */
+		gpio_set_value(GPIO_PHY_RESET, 0);
+		udelay(2);	/* PHY datasheet states 1uS min. */
+		gpio_set_value(GPIO_PHY_RESET, 1);
+	}
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_BOARD_LATE_INIT
+int board_late_init(void)
+{
+#if !defined(CONFIG_SPL_BUILD)
+	uint8_t mac_addr[6];
+	uint32_t mac_hi, mac_lo;
+#endif
+
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	char *name = NULL;
+
+	if (board_is_bone_lt()) {
+		puts("Board: BeagleBone Black\n");
+		name = "A335BNLT";
+		/* BeagleBoard.org BeagleBone Black Wireless: */
+		if (!strncmp(board_ti_get_rev(), "BWA", 3)) {
+			name = "BBBW";
+		}
+		/* SeeedStudio BeagleBone Green Wireless */
+		if (!strncmp(board_ti_get_rev(), "GW1", 3)) {
+			name = "BBGW";
+		}
+		/* BeagleBoard.org BeagleBone Blue */
+		if (!strncmp(board_ti_get_rev(), "BLA", 3)) {
+			name = "BBBL";
+		}
+		/* Octavo Systems OSD3358-SM-RED */
+		if (!strncmp(board_ti_get_rev(), "OS00", 4)) {
+			puts("Model: Octavo Systems OSD3358-SM-RED\n");
+			name = "OS00";
+		}
+	}
+
+	if (board_is_bbg1())
+		name = "BBG1";
+
+	if (board_is_bben()) {
+		puts("Model: SanCloud BeagleBone Enhanced\n");
+		name = "BBEN";
+		//Was: name = "SBBE";
+	}
+
+	if (board_is_pb()) {
+		puts("Model: BeagleBoard.org PocketBeagle\n");
+	}
+
+	if (board_is_beaglelogic()) {
+		puts("Model: BeagleLogic\n");
+	}
+
+	set_board_info_env(name);
+
+	/*
+	 * Default FIT boot on HS devices. Non FIT images are not allowed
+	 * on HS devices.
+	 */
+	if (get_device_type() == HS_DEVICE)
+		env_set("boot_fit", "1");
+#endif
+
+#if !defined(CONFIG_SPL_BUILD)
+	/* try reading mac address from efuse */
+	mac_lo = readl(&cdev->macid0l);
+	mac_hi = readl(&cdev->macid0h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+	if (!env_get("ethaddr")) {
+		printf("<ethaddr> not set. Validating first E-fuse MAC\n");
+
+		if (is_valid_ethaddr(mac_addr))
+			eth_env_set_enetaddr("ethaddr", mac_addr);
+	}
+
+	mac_lo = readl(&cdev->macid1l);
+	mac_hi = readl(&cdev->macid1h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+	if (!env_get("eth1addr")) {
+		if (is_valid_ethaddr(mac_addr))
+			eth_env_set_enetaddr("eth1addr", mac_addr);
+	}
+#endif
+
+	if (!env_get("serial#")) {
+		char *board_serial = env_get("board_serial");
+		char *ethaddr = env_get("ethaddr");
+
+		if (!board_serial || !strncmp(board_serial, "unknown", 7))
+			env_set("serial#", ethaddr);
+		else
+			env_set("serial#", board_serial);
+	}
+
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+#ifdef CONFIG_TI_I2C_BOARD_DETECT
+	if (!board_is_pb() && !board_is_beaglelogic()) {
+		do_cape_detect();
+	}
+#endif
+#endif
+
+	return 0;
+}
+#endif
+
+#ifndef CONFIG_DM_ETH
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+static void cpsw_control(int enabled)
+{
+	/* VTP can be added here */
+
+	return;
+}
+
+static struct cpsw_slave_data cpsw_slaves[] = {
+	{
+		.slave_reg_ofs	= 0x208,
+		.sliver_reg_ofs	= 0xd80,
+		.phy_addr	= 0,
+	},
+	{
+		.slave_reg_ofs	= 0x308,
+		.sliver_reg_ofs	= 0xdc0,
+		.phy_addr	= 1,
+	},
+};
+
+static struct cpsw_platform_data cpsw_data = {
+	.mdio_base		= CPSW_MDIO_BASE,
+	.cpsw_base		= CPSW_BASE,
+	.mdio_div		= 0xff,
+	.channels		= 8,
+	.cpdma_reg_ofs		= 0x800,
+	.slaves			= 1,
+	.slave_data		= cpsw_slaves,
+	.ale_reg_ofs		= 0xd00,
+	.ale_entries		= 1024,
+	.host_port_reg_ofs	= 0x108,
+	.hw_stats_reg_ofs	= 0x900,
+	.bd_ram_ofs		= 0x2000,
+	.mac_control		= (1 << 5),
+	.control		= cpsw_control,
+	.host_port_num		= 0,
+	.version		= CPSW_CTRL_VERSION_2,
+};
+#endif
+
+#if ((defined(CONFIG_SPL_ETH_SUPPORT) || defined(CONFIG_SPL_USB_ETHER)) &&\
+	defined(CONFIG_SPL_BUILD)) || \
+	((defined(CONFIG_DRIVER_TI_CPSW) || \
+	  defined(CONFIG_USB_ETHER) && defined(CONFIG_MUSB_GADGET)) && \
+	 !defined(CONFIG_SPL_BUILD))
+
+/*
+ * This function will:
+ * Read the eFuse for MAC addresses, and set ethaddr/eth1addr/usbnet_devaddr
+ * in the environment
+ * Perform fixups to the PHY present on certain boards.  We only need this
+ * function in:
+ * - SPL with either CPSW or USB ethernet support
+ * - Full U-Boot, with either CPSW or USB ethernet
+ * Build in only these cases to avoid warnings about unused variables
+ * when we build an SPL that has neither option but full U-Boot will.
+ */
+int board_eth_init(bd_t *bis)
+{
+	int rv, n = 0;
+#if defined(CONFIG_USB_ETHER) && \
+	(!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_USB_ETHER))
+	uint8_t mac_addr[6];
+	uint32_t mac_hi, mac_lo;
+
+	/*
+	 * use efuse mac address for USB ethernet as we know that
+	 * both CPSW and USB ethernet will never be active at the same time
+	 */
+	mac_lo = readl(&cdev->macid0l);
+	mac_hi = readl(&cdev->macid0h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+#endif
+
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+
+#ifdef CONFIG_DRIVER_TI_CPSW
+if (!board_is_pb()) {
+	if (board_is_bone() || (board_is_bone_lt() && !board_is_m10a() && !board_is_bben()) ||
+	    board_is_idk() || board_is_beaglelogic()) {
+		puts("eth0: MII MODE\n");
+		writel(MII_MODE_ENABLE, &cdev->miisel);
+		cpsw_slaves[0].phy_if = cpsw_slaves[1].phy_if =
+				PHY_INTERFACE_MODE_MII;
+	} else if (board_is_icev2()) {
+		puts("eth0: icev2: RGMII MODE\n");
+		writel(RMII_MODE_ENABLE | RMII_CHIPCKL_ENABLE, &cdev->miisel);
+		cpsw_slaves[0].phy_if = PHY_INTERFACE_MODE_RMII;
+		cpsw_slaves[1].phy_if = PHY_INTERFACE_MODE_RMII;
+		cpsw_slaves[0].phy_addr = 1;
+		cpsw_slaves[1].phy_addr = 3;
+	} else {
+		puts("eth0: RGMII MODE\n");
+		writel((RGMII_MODE_ENABLE | RGMII_INT_DELAY), &cdev->miisel);
+		cpsw_slaves[0].phy_if = cpsw_slaves[1].phy_if =
+				PHY_INTERFACE_MODE_RGMII;
+	}
+
+	rv = cpsw_register(&cpsw_data);
+	if (rv < 0)
+		printf("Error %d registering CPSW switch\n", rv);
+	else
+		n += rv;
+}
+#endif
+
+	/*
+	 *
+	 * CPSW RGMII Internal Delay Mode is not supported in all PVT
+	 * operating points.  So we must set the TX clock delay feature
+	 * in the AR8051 PHY.  Since we only support a single ethernet
+	 * device in U-Boot, we only do this for the first instance.
+	 */
+#define AR8051_PHY_DEBUG_ADDR_REG	0x1d
+#define AR8051_PHY_DEBUG_DATA_REG	0x1e
+#define AR8051_DEBUG_RGMII_CLK_DLY_REG	0x5
+#define AR8051_RGMII_TX_CLK_DLY		0x100
+
+	if (board_is_evm_sk() || board_is_gp_evm() || board_is_bben() || board_is_m10a()) {
+		const char *devname;
+		devname = miiphy_get_current_dev();
+
+		miiphy_write(devname, 0x0, AR8051_PHY_DEBUG_ADDR_REG,
+				AR8051_DEBUG_RGMII_CLK_DLY_REG);
+		miiphy_write(devname, 0x0, AR8051_PHY_DEBUG_DATA_REG,
+				AR8051_RGMII_TX_CLK_DLY);
+	}
+#endif
+#if defined(CONFIG_USB_ETHER) && \
+	(!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_USB_ETHER))
+	if (is_valid_ethaddr(mac_addr))
+		eth_env_set_enetaddr("usbnet_devaddr", mac_addr);
+
+	rv = usb_eth_initialize(bis);
+	if (rv < 0)
+		printf("Error %d registering USB_ETHER\n", rv);
+	else
+		n += rv;
+#endif
+	return n;
+}
+#endif
+
+#endif /* CONFIG_DM_ETH */
+
+#ifdef CONFIG_SPL_LOAD_FIT
+int board_fit_config_name_match(const char *name)
+{
+	//FIME: we currently dont use this, yet...
+	if (board_is_gp_evm() && !strcmp(name, "am335x-evm"))
+		return 0;
+	else if (board_is_bone() && !strcmp(name, "am335x-bone"))
+		return 0;
+	else if (board_is_bone_lt() && !strcmp(name, "am335x-boneblack"))
+		return 0;
+	else if (board_is_pb() && !strcmp(name, "am335x-pocketbeagle"))
+		return 0;
+	else if (board_is_evm_sk() && !strcmp(name, "am335x-evmsk"))
+		return 0;
+	else if (board_is_bbg1() && !strcmp(name, "am335x-bonegreen"))
+		return 0;
+	else if (board_is_icev2() && !strcmp(name, "am335x-icev2"))
+		return 0;
+	else
+		return -1;
+}
+#endif
+
+#ifdef CONFIG_TI_SECURE_DEVICE
+void board_fit_image_post_process(void **p_image, size_t *p_size)
+{
+	secure_boot_verify_image(p_image, p_size);
+}
+#endif
+
+#if !CONFIG_IS_ENABLED(OF_CONTROL)
+static const struct omap_hsmmc_plat am335x_mmc0_platdata = {
+	.base_addr = (struct hsmmc *)OMAP_HSMMC1_BASE,
+	.cfg.host_caps = MMC_MODE_HS_52MHz | MMC_MODE_HS | MMC_MODE_4BIT,
+	.cfg.f_min = 400000,
+	.cfg.f_max = 52000000,
+	.cfg.voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195,
+	.cfg.b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT,
+};
+
+U_BOOT_DEVICE(am335x_mmc0) = {
+	.name = "omap_hsmmc",
+	.platdata = &am335x_mmc0_platdata,
+};
+
+static const struct omap_hsmmc_plat am335x_mmc1_platdata = {
+	.base_addr = (struct hsmmc *)OMAP_HSMMC2_BASE,
+	.cfg.host_caps = MMC_MODE_HS_52MHz | MMC_MODE_HS | MMC_MODE_8BIT,
+	.cfg.f_min = 400000,
+	.cfg.f_max = 52000000,
+	.cfg.voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195,
+	.cfg.b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT,
+};
+
+U_BOOT_DEVICE(am335x_mmc1) = {
+	.name = "omap_hsmmc",
+	.platdata = &am335x_mmc1_platdata,
+};
+#endif
diff --color -rupN uboot-2019.04/board/ti/am335x/board.h uboot.b/board/ti/am335x/board.h
--- uboot-2019.04/board/ti/am335x/board.h	2020-12-14 14:53:34.630386873 +0100
+++ uboot.b/board/ti/am335x/board.h	2020-12-14 08:42:20.528888613 +0100
@@ -51,7 +51,9 @@ static inline int board_is_bone(void)
 
 static inline int board_is_bone_lt(void)
 {
-	return board_ti_is("A335BNLT");
+	//return board_ti_is("A335BNLT");
+	// TODO hier!!!
+	return 1;
 }
 
 static inline int board_is_pb(void)
diff --color -rupN uboot-2019.04/board/ti/am335x/Kconfig uboot.b/board/ti/am335x/Kconfig
--- uboot-2019.04/board/ti/am335x/Kconfig	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/board/ti/am335x/Kconfig	2020-12-14 08:42:20.528888613 +0100
@@ -19,6 +19,34 @@ config NOR
 	  In practice this is seen as a NOR flash module connected to the
 	  "memory cape" for the BeagleBone family.
 
+config CV_CLEAR_NAND_ENV
+	bool "CV-intern: Clear nand environment"
+	help
+	  If this flag is set, SPL clears the nand environment on start-up
+	  for a clean installation.
+	  
+config CV_KERNEL0_OFFS
+	hex "Offset of kernel partition 0"
+	help
+		Specify the offset in nand of the partition for kernel 0.
+		
+config CV_KERNEL1_OFFS
+	hex "Offset of kernel partition 1"
+	help
+		Specify the offset in nand of the partition for kernel 1.
+		
+config  CV_KPARAMS0_OFFS
+	hex "Offset of NAND.kparams0"
+	
+config CV_KPARAMS1_OFFS
+	hex "Offset of NAND.kparams1"
+	
+config CV_BOOTCOUNT_LIMIT
+	int "CV_BOOTCOUNT_LIMIT (danach fallback zum andern rootfs)"
+	help
+		Wenn in so vielen Boot-Vorgaengen prtsoft nicht /scripts/eeprom_bootcount_set.sh 0 aufgerufen hat, 
+		wird ein fallback zur anderen rootfs-partition gemacht.
+
 source "board/ti/common/Kconfig"
 
 endif
diff --color -rupN uboot-2019.04/board/ti/am335x/mux.c uboot.b/board/ti/am335x/mux.c
--- uboot-2019.04/board/ti/am335x/mux.c	2020-12-14 14:53:34.646386923 +0100
+++ uboot.b/board/ti/am335x/mux.c	2020-12-14 08:42:20.528888613 +0100
@@ -25,6 +25,7 @@
 static struct module_pin_mux uart0_pin_mux[] = {
 	{OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART0_RXD */
 	{OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},		/* UART0_TXD */
+	{OFFSET(uart0_rtsn), (MODE(0) | PULLUDDIS)}, /* UART0_RTSN, unklar ob no-pull wirklich die richtige wahl... */
 	{-1},
 };
 
@@ -59,6 +60,7 @@ static struct module_pin_mux uart5_pin_m
 };
 
 static struct module_pin_mux mmc0_pin_mux[] = {
+#if 1
 	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
 	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
 	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
@@ -67,6 +69,17 @@ static struct module_pin_mux mmc0_pin_mu
 	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
 	{OFFSET(spi0_cs1), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* GPIO0_6 */
 	{-1},
+#else
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{OFFSET(spi0_cs1), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* GPIO0_6 */
+	{-1},
+#endif
 };
 
 static struct module_pin_mux mmc0_no_cd_pin_mux[] = {
@@ -119,14 +132,6 @@ static struct module_pin_mux i2c1_pin_mu
 	{-1},
 };
 
-static struct module_pin_mux i2c2_pin_mux[] = {
-	{OFFSET(uart1_ctsn), (MODE(3) | RXACTIVE |
-			PULLUP_EN | PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
-	{OFFSET(uart1_rtsn), (MODE(3) | RXACTIVE |
-			PULLUP_EN | PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
-	{-1},
-};
-
 static struct module_pin_mux spi0_pin_mux[] = {
 	{OFFSET(spi0_sclk), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_SCLK */
 	{OFFSET(spi0_d0), (MODE(0) | RXACTIVE |
@@ -200,6 +205,7 @@ static struct module_pin_mux rmii1_pin_m
 
 #ifdef CONFIG_NAND
 static struct module_pin_mux nand_pin_mux[] = {
+#if 1 /* original */
 	{OFFSET(gpmc_ad0),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD0  */
 	{OFFSET(gpmc_ad1),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD1  */
 	{OFFSET(gpmc_ad2),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD2  */
@@ -226,6 +232,24 @@ static struct module_pin_mux nand_pin_mu
 	{OFFSET(gpmc_advn_ale),	(MODE(0) | PULLDOWN_EN)},	   /* ADV_ALE */
 	{OFFSET(gpmc_be0n_cle),	(MODE(0) | PULLDOWN_EN)},	   /* BE_CLE */
 	{-1},
+#else /* von kurz */
+	{OFFSET(gpmc_ad0), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD0 */
+	{OFFSET(gpmc_ad1), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD1 */
+	{OFFSET(gpmc_ad2), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD2 */
+	{OFFSET(gpmc_ad3), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD3 */
+	{OFFSET(gpmc_ad4), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD4 */
+	{OFFSET(gpmc_ad5), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD5 */
+	{OFFSET(gpmc_ad6), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD6 */
+	{OFFSET(gpmc_ad7), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD7 */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUP_EN)}, /* NAND WAIT */
+	{OFFSET(gpmc_wpn), (MODE(7) | PULLUP_EN | RXACTIVE)},	/* NAND_WPN */
+	{OFFSET(gpmc_csn0), (MODE(0) | PULLUDEN)},	/* NAND_CS0 */
+	{OFFSET(gpmc_advn_ale), (MODE(0) | PULLUDEN)}, /* NAND_ADV_ALE */
+	{OFFSET(gpmc_oen_ren), (MODE(0) | PULLUDEN)},	/* NAND_OE */
+	{OFFSET(gpmc_wen), (MODE(0) | PULLUDEN)},	/* NAND_WEN */
+	{OFFSET(gpmc_be0n_cle), (MODE(0) | PULLUDEN)},	/* NAND_BE_CLE */
+	{-1},
+#endif
 };
 #elif defined(CONFIG_NOR)
 static struct module_pin_mux bone_norcape_pin_mux[] = {
@@ -311,11 +335,6 @@ void enable_i2c0_pin_mux(void)
 	configure_module_pin_mux(i2c0_pin_mux);
 }
 
-void enable_i2c2_pin_mux(void)
-{
-	configure_module_pin_mux(i2c2_pin_mux);
-}
-
 /*
  * The AM335x GP EVM, if daughter card(s) are connected, can have 8
  * different profiles.  These profiles determine what peripherals are
@@ -341,46 +360,45 @@ static unsigned short detect_daughter_bo
 {
 	unsigned short val;
 
-#ifndef CONFIG_DM_I2C
 	if (i2c_probe(I2C_CPLD_ADDR))
 		return PROFILE_NONE;
 
 	if (i2c_read(I2C_CPLD_ADDR, CFG_REG, 1, (unsigned char *)(&val), 2))
 		return PROFILE_NONE;
-#else
-	struct udevice *dev = NULL;
-	int rc;
 
-	rc = i2c_get_chip_for_busnum(0, I2C_CPLD_ADDR, 1, &dev);
-	if (rc)
-		return PROFILE_NONE;
-	rc = dm_i2c_read(dev, CFG_REG, (unsigned char *)(&val), 2);
-	if (rc)
-		return PROFILE_NONE;
-#endif
 	return (1 << (val & PROFILE_MASK));
 }
 
+char mux_buf[4096];
+
 void enable_board_pin_mux(void)
 {
+	puts("enable_board_pin_mux\n");
+	char* sp = mux_buf;
+	sp[0] = 't';
+	sp[1] = 'e';
+	sp[2] = 's';
+	sp[3] = 't';
+	sp[4] = 0;
+
 	/* Do board-specific muxes. */
-	if (board_is_beaglelogic()) {
-		/* BeagleLogic pinmux */
-		configure_module_pin_mux(mii1_pin_mux);
-		configure_module_pin_mux(mmc0_pin_mux);
-	} else if (board_is_bone()) {
+	if (board_is_bone()) {
+//		sp += sprintf(sp, "preitinger: if board_is_bone\n");
 		/* Beaglebone pinmux */
-		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(rgmii1_pin_mux);
 		configure_module_pin_mux(mmc0_pin_mux);
 #if defined(CONFIG_NAND)
+	//sp +=  sprintf(sp, "preitinger: defined(CONFIG_NAND)\n");
 		configure_module_pin_mux(nand_pin_mux);
 #elif defined(CONFIG_NOR)
+	//sp +=  sprintf(sp, "preitinger: defined(CONFIG_NOR)\n");
 		configure_module_pin_mux(bone_norcape_pin_mux);
 #else
+	//sp +=  sprintf(sp, "preitinger: weder defined(CONFIG_NAND) noch defined(CONFIG_NOR)\n");
 		configure_module_pin_mux(mmc1_pin_mux);
 #endif
-		configure_module_pin_mux(i2c2_pin_mux);
 	} else if (board_is_gp_evm()) {
+		//sp +=  sprintf(sp, "preitinger: if board_is_gp_evm\n");
 		/* General Purpose EVM */
 		unsigned short profile = detect_daughter_board_profile();
 		configure_module_pin_mux(rgmii1_pin_mux);
@@ -390,6 +408,7 @@ void enable_board_pin_mux(void)
 			configure_module_pin_mux(i2c1_pin_mux);
 		/* Profiles 2 & 3 don't have NAND */
 #ifdef CONFIG_NAND
+//#error config_nand 2
 		if (profile & ~(PROFILE_2 | PROFILE_3))
 			configure_module_pin_mux(nand_pin_mux);
 #endif
@@ -398,47 +417,60 @@ void enable_board_pin_mux(void)
 			configure_module_pin_mux(spi0_pin_mux);
 		}
 	} else if (board_is_idk()) {
+		//sp +=  sprintf(sp, "preitinger: if board_is_idk\n");
 		/* Industrial Motor Control (IDK) */
 		configure_module_pin_mux(mii1_pin_mux);
 		configure_module_pin_mux(mmc0_no_cd_pin_mux);
 	} else if (board_is_evm_sk()) {
+		//sp +=  sprintf(sp, "preitinger: if board_is_evm_sk\n");
 		/* Starter Kit EVM */
 		configure_module_pin_mux(i2c1_pin_mux);
 		configure_module_pin_mux(gpio0_7_pin_mux);
 		configure_module_pin_mux(rgmii1_pin_mux);
 		configure_module_pin_mux(mmc0_pin_mux_sk_evm);
 	} else if (board_is_bone_lt()) {
-		if (board_is_bben() || board_is_m10a()) {
-			/* SanCloud Beaglebone LT Enhanced pinmux */
-			configure_module_pin_mux(rgmii1_pin_mux);
-		} else {
-			/* Beaglebone LT pinmux */
-			configure_module_pin_mux(mii1_pin_mux);
-		}
+		//sp +=  sprintf(sp, "preitinger: if board_is_bone_lt\n");
+		/* Beaglebone LT pinmux */
+		configure_module_pin_mux(mii1_pin_mux);
 		configure_module_pin_mux(mmc0_pin_mux);
-#if defined(CONFIG_NAND) && defined(CONFIG_EMMC_BOOT)
+#if defined(CONFIG_NAND) // preitinger: wozu? && defined(CONFIG_EMMC_BOOT)
+		//sp +=  sprintf(sp, "preitinger: defined(CONFIG_NAND) && defined(CONFIG_EMMC_BOOT)\n");
 		configure_module_pin_mux(nand_pin_mux);
 #elif defined(CONFIG_NOR) && defined(CONFIG_EMMC_BOOT)
+		//sp +=  sprintf(sp, "preitinger: defined(CONFIG_NOR) && defined(CONFIG_EMMC_BOOT)\n");
 		configure_module_pin_mux(bone_norcape_pin_mux);
 #else
+		//sp +=  sprintf(sp, "preitinger: weder defined(CONFIG_NAND) && defined(CONFIG_EMMC_BOOT) noch defined(CONFIG_NOR) && defined(CONFIG_EMMC_BOOT)\n");
 		configure_module_pin_mux(mmc1_pin_mux);
 #endif
-		configure_module_pin_mux(i2c2_pin_mux);
-	} else if (board_is_pb()) {
-		configure_module_pin_mux(mii1_pin_mux);
-		configure_module_pin_mux(mmc0_pin_mux);
 	} else if (board_is_icev2()) {
+		//sp +=  sprintf(sp, "preitinger: board_is_icev2\n");
 		configure_module_pin_mux(mmc0_pin_mux);
 		configure_module_pin_mux(gpio0_18_pin_mux);
 		configure_module_pin_mux(uart3_icev2_pin_mux);
 		configure_module_pin_mux(rmii1_pin_mux);
 		configure_module_pin_mux(spi0_pin_mux);
 	} else {
+		//sp +=  sprintf(sp, "preitinger: unknown board\n");
 		/* Unknown board. We might still be able to boot. */
 		puts("Bad EEPROM or unknown board, cannot configure pinmux.");
 	}
-
-	// preitinger: immer pin muxing fuer nand und i2c0 damit nand und eeprom verfuegbar fuer update-funktionalitaet 
+	// preitinger: immer nand zur probe:
 	configure_module_pin_mux(nand_pin_mux);
 	enable_i2c0_pin_mux();
+	//sp +=  sprintf(sp, "preitinger: nach nand_pin_mux\n");
 }
+
+static struct module_pin_mux i2c2_pin_mux[] = {
+	{OFFSET(uart1_ctsn), (MODE(3) | RXACTIVE |
+			PULLUP_EN | PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(uart1_rtsn), (MODE(3) | RXACTIVE |
+			PULLUP_EN | PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+void enable_i2c2_pin_mux(void)
+{
+	configure_module_pin_mux(i2c2_pin_mux);
+}
+
diff --color -rupN uboot-2019.04/board/ti/am335x/mux.c~ uboot.b/board/ti/am335x/mux.c~
--- uboot-2019.04/board/ti/am335x/mux.c~	1970-01-01 01:00:00.000000000 +0100
+++ uboot.b/board/ti/am335x/mux.c~	2020-12-14 08:42:20.476888415 +0100
@@ -0,0 +1,474 @@
+/*
+ * mux.c
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include "../common/board_detect.h"
+#include "board.h"
+
+static struct module_pin_mux uart0_pin_mux[] = {
+	{OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART0_RXD */
+	{OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},		/* UART0_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart1_pin_mux[] = {
+	{OFFSET(uart1_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART1_RXD */
+	{OFFSET(uart1_txd), (MODE(0) | PULLUDEN)},		/* UART1_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart2_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART2_RXD */
+	{OFFSET(spi0_d0), (MODE(1) | PULLUDEN)},		/* UART2_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart3_pin_mux[] = {
+	{OFFSET(spi0_cs1), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART3_RXD */
+	{OFFSET(ecap0_in_pwm0_out), (MODE(1) | PULLUDEN)},	/* UART3_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart4_pin_mux[] = {
+	{OFFSET(gpmc_wait0), (MODE(6) | PULLUP_EN | RXACTIVE)},	/* UART4_RXD */
+	{OFFSET(gpmc_wpn), (MODE(6) | PULLUDEN)},		/* UART4_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart5_pin_mux[] = {
+	{OFFSET(lcd_data9), (MODE(4) | PULLUP_EN | RXACTIVE)},	/* UART5_RXD */
+	{OFFSET(lcd_data8), (MODE(4) | PULLUDEN)},		/* UART5_TXD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux[] = {
+#if 1
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(spi0_cs1), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* GPIO0_6 */
+	{-1},
+#else
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{OFFSET(spi0_cs1), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* GPIO0_6 */
+	{-1},
+#endif
+};
+
+static struct module_pin_mux mmc0_no_cd_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux_sk_evm[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc1_pin_mux[] = {
+	{OFFSET(gpmc_ad3), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT3 */
+	{OFFSET(gpmc_ad2), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT2 */
+	{OFFSET(gpmc_ad1), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT1 */
+	{OFFSET(gpmc_ad0), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT0 */
+	{OFFSET(gpmc_csn1), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CLK */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CMD */
+	{OFFSET(gpmc_csn0), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_WP */
+	{OFFSET(gpmc_advn_ale), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_CD */
+	{-1},
+};
+
+static struct module_pin_mux i2c0_pin_mux[] = {
+	{OFFSET(i2c0_sda), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_DATA */
+	{OFFSET(i2c0_scl), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux i2c1_pin_mux[] = {
+	{OFFSET(spi0_d1), (MODE(2) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(spi0_cs0), (MODE(2) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux spi0_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_SCLK */
+	{OFFSET(spi0_d0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_D0 */
+	{OFFSET(spi0_d1), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_D1 */
+	{OFFSET(spi0_cs0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_CS0 */
+	{-1},
+};
+
+static struct module_pin_mux gpio0_7_pin_mux[] = {
+	{OFFSET(ecap0_in_pwm0_out), (MODE(7) | PULLUDEN)},	/* GPIO0_7 */
+	{-1},
+};
+
+static struct module_pin_mux gpio0_18_pin_mux[] = {
+	{OFFSET(usb0_drvvbus), (MODE(7) | PULLUDEN)},	/* GPIO0_18 */
+	{-1},
+};
+
+static struct module_pin_mux rgmii1_pin_mux[] = {
+	{OFFSET(mii1_txen), MODE(2)},			/* RGMII1_TCTL */
+	{OFFSET(mii1_rxdv), MODE(2) | RXACTIVE},	/* RGMII1_RCTL */
+	{OFFSET(mii1_txd3), MODE(2)},			/* RGMII1_TD3 */
+	{OFFSET(mii1_txd2), MODE(2)},			/* RGMII1_TD2 */
+	{OFFSET(mii1_txd1), MODE(2)},			/* RGMII1_TD1 */
+	{OFFSET(mii1_txd0), MODE(2)},			/* RGMII1_TD0 */
+	{OFFSET(mii1_txclk), MODE(2)},			/* RGMII1_TCLK */
+	{OFFSET(mii1_rxclk), MODE(2) | RXACTIVE},	/* RGMII1_RCLK */
+	{OFFSET(mii1_rxd3), MODE(2) | RXACTIVE},	/* RGMII1_RD3 */
+	{OFFSET(mii1_rxd2), MODE(2) | RXACTIVE},	/* RGMII1_RD2 */
+	{OFFSET(mii1_rxd1), MODE(2) | RXACTIVE},	/* RGMII1_RD1 */
+	{OFFSET(mii1_rxd0), MODE(2) | RXACTIVE},	/* RGMII1_RD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN},/* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux mii1_pin_mux[] = {
+	{OFFSET(mii1_rxerr), MODE(0) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(0)},			/* MII1_TXEN */
+	{OFFSET(mii1_rxdv), MODE(0) | RXACTIVE},	/* MII1_RXDV */
+	{OFFSET(mii1_txd3), MODE(0)},			/* MII1_TXD3 */
+	{OFFSET(mii1_txd2), MODE(0)},			/* MII1_TXD2 */
+	{OFFSET(mii1_txd1), MODE(0)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(0)},			/* MII1_TXD0 */
+	{OFFSET(mii1_txclk), MODE(0) | RXACTIVE},	/* MII1_TXCLK */
+	{OFFSET(mii1_rxclk), MODE(0) | RXACTIVE},	/* MII1_RXCLK */
+	{OFFSET(mii1_rxd3), MODE(0) | RXACTIVE},	/* MII1_RXD3 */
+	{OFFSET(mii1_rxd2), MODE(0) | RXACTIVE},	/* MII1_RXD2 */
+	{OFFSET(mii1_rxd1), MODE(0) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(0) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux rmii1_pin_mux[] = {
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mii1_crs), MODE(1) | RXACTIVE},		/* MII1_CRS */
+	{OFFSET(mii1_rxerr), MODE(1) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(1)},			/* MII1_TXEN */
+	{OFFSET(mii1_txd1), MODE(1)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(1)},			/* MII1_TXD0 */
+	{OFFSET(mii1_rxd1), MODE(1) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(1) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(rmii1_refclk), MODE(0) | RXACTIVE},	/* RMII1_REFCLK */
+	{-1},
+};
+
+#ifdef CONFIG_NAND
+static struct module_pin_mux nand_pin_mux[] = {
+#if 1 /* original */
+	{OFFSET(gpmc_ad0),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD0  */
+	{OFFSET(gpmc_ad1),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD1  */
+	{OFFSET(gpmc_ad2),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD2  */
+	{OFFSET(gpmc_ad3),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD3  */
+	{OFFSET(gpmc_ad4),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD4  */
+	{OFFSET(gpmc_ad5),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD5  */
+	{OFFSET(gpmc_ad6),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD6  */
+	{OFFSET(gpmc_ad7),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD7  */
+#ifdef CONFIG_SYS_NAND_BUSWIDTH_16BIT
+	{OFFSET(gpmc_ad8),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD8  */
+	{OFFSET(gpmc_ad9),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD9  */
+	{OFFSET(gpmc_ad10),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD10 */
+	{OFFSET(gpmc_ad11),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD11 */
+	{OFFSET(gpmc_ad12),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD12 */
+	{OFFSET(gpmc_ad13),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD13 */
+	{OFFSET(gpmc_ad14),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD14 */
+	{OFFSET(gpmc_ad15),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD15 */
+#endif
+	{OFFSET(gpmc_wait0),	(MODE(0) | PULLUP_EN | RXACTIVE)}, /* nWAIT */
+	{OFFSET(gpmc_wpn),	(MODE(7) | PULLUP_EN)},		   /* nWP */
+	{OFFSET(gpmc_csn0),	(MODE(0) | PULLUP_EN)},		   /* nCS */
+	{OFFSET(gpmc_wen),	(MODE(0) | PULLDOWN_EN)},	   /* WEN */
+	{OFFSET(gpmc_oen_ren),	(MODE(0) | PULLDOWN_EN)},	   /* OE */
+	{OFFSET(gpmc_advn_ale),	(MODE(0) | PULLDOWN_EN)},	   /* ADV_ALE */
+	{OFFSET(gpmc_be0n_cle),	(MODE(0) | PULLDOWN_EN)},	   /* BE_CLE */
+	{-1},
+#else /* von kurz */
+	{OFFSET(gpmc_ad0), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD0 */
+	{OFFSET(gpmc_ad1), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD1 */
+	{OFFSET(gpmc_ad2), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD2 */
+	{OFFSET(gpmc_ad3), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD3 */
+	{OFFSET(gpmc_ad4), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD4 */
+	{OFFSET(gpmc_ad5), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD5 */
+	{OFFSET(gpmc_ad6), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD6 */
+	{OFFSET(gpmc_ad7), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD7 */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUP_EN)}, /* NAND WAIT */
+	{OFFSET(gpmc_wpn), (MODE(7) | PULLUP_EN | RXACTIVE)},	/* NAND_WPN */
+	{OFFSET(gpmc_csn0), (MODE(0) | PULLUDEN)},	/* NAND_CS0 */
+	{OFFSET(gpmc_advn_ale), (MODE(0) | PULLUDEN)}, /* NAND_ADV_ALE */
+	{OFFSET(gpmc_oen_ren), (MODE(0) | PULLUDEN)},	/* NAND_OE */
+	{OFFSET(gpmc_wen), (MODE(0) | PULLUDEN)},	/* NAND_WEN */
+	{OFFSET(gpmc_be0n_cle), (MODE(0) | PULLUDEN)},	/* NAND_BE_CLE */
+	{-1},
+#endif
+};
+#elif defined(CONFIG_NOR)
+static struct module_pin_mux bone_norcape_pin_mux[] = {
+	{OFFSET(gpmc_a0), MODE(0) | PULLUDDIS},			/* NOR_A0 */
+	{OFFSET(gpmc_a1), MODE(0) | PULLUDDIS},			/* NOR_A1 */
+	{OFFSET(gpmc_a2), MODE(0) | PULLUDDIS},			/* NOR_A2 */
+	{OFFSET(gpmc_a3), MODE(0) | PULLUDDIS},			/* NOR_A3 */
+	{OFFSET(gpmc_a4), MODE(0) | PULLUDDIS},			/* NOR_A4 */
+	{OFFSET(gpmc_a5), MODE(0) | PULLUDDIS},			/* NOR_A5 */
+	{OFFSET(gpmc_a6), MODE(0) | PULLUDDIS},			/* NOR_A6 */
+	{OFFSET(gpmc_a7), MODE(0) | PULLUDDIS},			/* NOR_A7 */
+	{OFFSET(gpmc_ad0), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD0 */
+	{OFFSET(gpmc_ad1), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD1 */
+	{OFFSET(gpmc_ad2), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD2 */
+	{OFFSET(gpmc_ad3), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD3 */
+	{OFFSET(gpmc_ad4), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD4 */
+	{OFFSET(gpmc_ad5), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD5 */
+	{OFFSET(gpmc_ad6), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD6 */
+	{OFFSET(gpmc_ad7), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD7 */
+	{OFFSET(gpmc_ad8), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD8 */
+	{OFFSET(gpmc_ad9), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD9 */
+	{OFFSET(gpmc_ad10), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD10 */
+	{OFFSET(gpmc_ad11), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD11 */
+	{OFFSET(gpmc_ad12), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD12 */
+	{OFFSET(gpmc_ad13), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD13 */
+	{OFFSET(gpmc_ad14), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD14 */
+	{OFFSET(gpmc_ad15), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD15 */
+	{OFFSET(gpmc_csn0), MODE(0) | PULLUDEN | PULLUP_EN},     /* CE */
+	{OFFSET(gpmc_advn_ale), MODE(0) | PULLUDEN | PULLDOWN_EN}, /* ALE */
+	{OFFSET(gpmc_oen_ren), MODE(0) | PULLUDEN | PULLDOWN_EN},/* OEn_REN */
+	{OFFSET(gpmc_be0n_cle), MODE(0) | PULLUDEN | PULLDOWN_EN},/* unused */
+	{OFFSET(gpmc_wen), MODE(0) | PULLUDEN | PULLDOWN_EN},    /* WEN */
+	{OFFSET(gpmc_wait0), MODE(0) | PULLUDEN | PULLUP_EN | RXACTIVE},/*WAIT*/
+	{-1},
+};
+#endif
+
+static struct module_pin_mux uart3_icev2_pin_mux[] = {
+	{OFFSET(mii1_rxd3), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART3_RXD */
+	{OFFSET(mii1_rxd2), MODE(1) | PULLUDEN},		/* UART3_TXD */
+	{-1},
+};
+
+#if defined(CONFIG_NOR_BOOT)
+void enable_norboot_pin_mux(void)
+{
+	configure_module_pin_mux(bone_norcape_pin_mux);
+}
+#endif
+
+void enable_uart0_pin_mux(void)
+{
+	configure_module_pin_mux(uart0_pin_mux);
+}
+
+void enable_uart1_pin_mux(void)
+{
+	configure_module_pin_mux(uart1_pin_mux);
+}
+
+void enable_uart2_pin_mux(void)
+{
+	configure_module_pin_mux(uart2_pin_mux);
+}
+
+void enable_uart3_pin_mux(void)
+{
+	configure_module_pin_mux(uart3_pin_mux);
+}
+
+void enable_uart4_pin_mux(void)
+{
+	configure_module_pin_mux(uart4_pin_mux);
+}
+
+void enable_uart5_pin_mux(void)
+{
+	configure_module_pin_mux(uart5_pin_mux);
+}
+
+void enable_i2c0_pin_mux(void)
+{
+	configure_module_pin_mux(i2c0_pin_mux);
+}
+
+/*
+ * The AM335x GP EVM, if daughter card(s) are connected, can have 8
+ * different profiles.  These profiles determine what peripherals are
+ * valid and need pinmux to be configured.
+ */
+#define PROFILE_NONE	0x0
+#define PROFILE_0	(1 << 0)
+#define PROFILE_1	(1 << 1)
+#define PROFILE_2	(1 << 2)
+#define PROFILE_3	(1 << 3)
+#define PROFILE_4	(1 << 4)
+#define PROFILE_5	(1 << 5)
+#define PROFILE_6	(1 << 6)
+#define PROFILE_7	(1 << 7)
+#define PROFILE_MASK	0x7
+#define PROFILE_ALL	0xFF
+
+/* CPLD registers */
+#define I2C_CPLD_ADDR	0x35
+#define CFG_REG		0x10
+
+static unsigned short detect_daughter_board_profile(void)
+{
+	unsigned short val;
+
+	if (i2c_probe(I2C_CPLD_ADDR))
+		return PROFILE_NONE;
+
+	if (i2c_read(I2C_CPLD_ADDR, CFG_REG, 1, (unsigned char *)(&val), 2))
+		return PROFILE_NONE;
+
+	return (1 << (val & PROFILE_MASK));
+}
+
+char mux_buf[4096];
+
+void enable_board_pin_mux(void)
+{
+	puts("enable_board_pin_mux\n");
+	char* sp = mux_buf;
+	sp[0] = 't';
+	sp[1] = 'e';
+	sp[2] = 's';
+	sp[3] = 't';
+	sp[4] = 0;
+
+	/* Do board-specific muxes. */
+	if (board_is_bone()) {
+//		sp += sprintf(sp, "preitinger: if board_is_bone\n");
+		/* Beaglebone pinmux */
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+#if defined(CONFIG_NAND)
+	//sp +=  sprintf(sp, "preitinger: defined(CONFIG_NAND)\n");
+		configure_module_pin_mux(nand_pin_mux);
+#elif defined(CONFIG_NOR)
+	//sp +=  sprintf(sp, "preitinger: defined(CONFIG_NOR)\n");
+		configure_module_pin_mux(bone_norcape_pin_mux);
+#else
+	//sp +=  sprintf(sp, "preitinger: weder defined(CONFIG_NAND) noch defined(CONFIG_NOR)\n");
+		configure_module_pin_mux(mmc1_pin_mux);
+#endif
+	} else if (board_is_gp_evm()) {
+		//sp +=  sprintf(sp, "preitinger: if board_is_gp_evm\n");
+		/* General Purpose EVM */
+		unsigned short profile = detect_daughter_board_profile();
+		configure_module_pin_mux(rgmii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+		/* In profile #2 i2c1 and spi0 conflict. */
+		if (profile & ~PROFILE_2)
+			configure_module_pin_mux(i2c1_pin_mux);
+		/* Profiles 2 & 3 don't have NAND */
+#ifdef CONFIG_NAND
+//#error config_nand 2
+		if (profile & ~(PROFILE_2 | PROFILE_3))
+			configure_module_pin_mux(nand_pin_mux);
+#endif
+		else if (profile == PROFILE_2) {
+			configure_module_pin_mux(mmc1_pin_mux);
+			configure_module_pin_mux(spi0_pin_mux);
+		}
+	} else if (board_is_idk()) {
+		//sp +=  sprintf(sp, "preitinger: if board_is_idk\n");
+		/* Industrial Motor Control (IDK) */
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_no_cd_pin_mux);
+	} else if (board_is_evm_sk()) {
+		//sp +=  sprintf(sp, "preitinger: if board_is_evm_sk\n");
+		/* Starter Kit EVM */
+		configure_module_pin_mux(i2c1_pin_mux);
+		configure_module_pin_mux(gpio0_7_pin_mux);
+		configure_module_pin_mux(rgmii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux_sk_evm);
+	} else if (board_is_bone_lt()) {
+		//sp +=  sprintf(sp, "preitinger: if board_is_bone_lt\n");
+		/* Beaglebone LT pinmux */
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+#if defined(CONFIG_NAND) // preitinger: wozu? && defined(CONFIG_EMMC_BOOT)
+		//sp +=  sprintf(sp, "preitinger: defined(CONFIG_NAND) && defined(CONFIG_EMMC_BOOT)\n");
+		configure_module_pin_mux(nand_pin_mux);
+#elif defined(CONFIG_NOR) && defined(CONFIG_EMMC_BOOT)
+		//sp +=  sprintf(sp, "preitinger: defined(CONFIG_NOR) && defined(CONFIG_EMMC_BOOT)\n");
+		configure_module_pin_mux(bone_norcape_pin_mux);
+#else
+		//sp +=  sprintf(sp, "preitinger: weder defined(CONFIG_NAND) && defined(CONFIG_EMMC_BOOT) noch defined(CONFIG_NOR) && defined(CONFIG_EMMC_BOOT)\n");
+		configure_module_pin_mux(mmc1_pin_mux);
+#endif
+	} else if (board_is_icev2()) {
+		//sp +=  sprintf(sp, "preitinger: board_is_icev2\n");
+		configure_module_pin_mux(mmc0_pin_mux);
+		configure_module_pin_mux(gpio0_18_pin_mux);
+		configure_module_pin_mux(uart3_icev2_pin_mux);
+		configure_module_pin_mux(rmii1_pin_mux);
+		configure_module_pin_mux(spi0_pin_mux);
+	} else {
+		//sp +=  sprintf(sp, "preitinger: unknown board\n");
+		/* Unknown board. We might still be able to boot. */
+		puts("Bad EEPROM or unknown board, cannot configure pinmux.");
+	}
+	// preitinger: immer nand zur probe:
+	configure_module_pin_mux(nand_pin_mux);
+	//sp +=  sprintf(sp, "preitinger: nach nand_pin_mux\n");
+}
+
+static struct module_pin_mux i2c2_pin_mux[] = {
+	{OFFSET(uart1_ctsn), (MODE(3) | RXACTIVE |
+			PULLUP_EN | PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(uart1_rtsn), (MODE(3) | RXACTIVE |
+			PULLUP_EN | PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+void enable_i2c2_pin_mux(void)
+{
+	configure_module_pin_mux(i2c2_pin_mux);
+}
+
diff --color -rupN uboot-2019.04/board/ti/am335x/mux.c_ORIG uboot.b/board/ti/am335x/mux.c_ORIG
--- uboot-2019.04/board/ti/am335x/mux.c_ORIG	1970-01-01 01:00:00.000000000 +0100
+++ uboot.b/board/ti/am335x/mux.c_ORIG	2020-12-14 08:42:20.532888627 +0100
@@ -0,0 +1,475 @@
+/*
+ * mux.c
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include "../common/board_detect.h"
+#include "board.h"
+
+static struct module_pin_mux uart0_pin_mux[] = {
+	{OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART0_RXD */
+	{OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},		/* UART0_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart1_pin_mux[] = {
+	{OFFSET(uart1_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART1_RXD */
+	{OFFSET(uart1_txd), (MODE(0) | PULLUDEN)},		/* UART1_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart2_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART2_RXD */
+	{OFFSET(spi0_d0), (MODE(1) | PULLUDEN)},		/* UART2_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart3_pin_mux[] = {
+	{OFFSET(spi0_cs1), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART3_RXD */
+	{OFFSET(ecap0_in_pwm0_out), (MODE(1) | PULLUDEN)},	/* UART3_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart4_pin_mux[] = {
+	{OFFSET(gpmc_wait0), (MODE(6) | PULLUP_EN | RXACTIVE)},	/* UART4_RXD */
+	{OFFSET(gpmc_wpn), (MODE(6) | PULLUDEN)},		/* UART4_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart5_pin_mux[] = {
+	{OFFSET(lcd_data9), (MODE(4) | PULLUP_EN | RXACTIVE)},	/* UART5_RXD */
+	{OFFSET(lcd_data8), (MODE(4) | PULLUDEN)},		/* UART5_TXD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(spi0_cs1), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* GPIO0_6 */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_no_cd_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux_sk_evm[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc1_pin_mux[] = {
+	{OFFSET(gpmc_ad3), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT3 */
+	{OFFSET(gpmc_ad2), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT2 */
+	{OFFSET(gpmc_ad1), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT1 */
+	{OFFSET(gpmc_ad0), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT0 */
+	{OFFSET(gpmc_csn1), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CLK */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CMD */
+	{OFFSET(gpmc_csn0), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_WP */
+	{OFFSET(gpmc_advn_ale), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_CD */
+	{-1},
+};
+
+static struct module_pin_mux i2c0_pin_mux[] = {
+	{OFFSET(i2c0_sda), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_DATA */
+	{OFFSET(i2c0_scl), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux i2c1_pin_mux[] = {
+	{OFFSET(spi0_d1), (MODE(2) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(spi0_cs0), (MODE(2) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux i2c2_pin_mux[] = {
+	{OFFSET(uart1_ctsn), (MODE(3) | RXACTIVE |
+			PULLUP_EN | PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(uart1_rtsn), (MODE(3) | RXACTIVE |
+			PULLUP_EN | PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux spi0_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_SCLK */
+	{OFFSET(spi0_d0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_D0 */
+	{OFFSET(spi0_d1), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_D1 */
+	{OFFSET(spi0_cs0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_CS0 */
+	{-1},
+};
+
+static struct module_pin_mux gpio0_7_pin_mux[] = {
+	{OFFSET(ecap0_in_pwm0_out), (MODE(7) | PULLUDEN)},	/* GPIO0_7 */
+	{-1},
+};
+
+static struct module_pin_mux gpio0_18_pin_mux[] = {
+	{OFFSET(usb0_drvvbus), (MODE(7) | PULLUDEN)},	/* GPIO0_18 */
+	{-1},
+};
+
+static struct module_pin_mux rgmii1_pin_mux[] = {
+	{OFFSET(mii1_txen), MODE(2)},			/* RGMII1_TCTL */
+	{OFFSET(mii1_rxdv), MODE(2) | RXACTIVE},	/* RGMII1_RCTL */
+	{OFFSET(mii1_txd3), MODE(2)},			/* RGMII1_TD3 */
+	{OFFSET(mii1_txd2), MODE(2)},			/* RGMII1_TD2 */
+	{OFFSET(mii1_txd1), MODE(2)},			/* RGMII1_TD1 */
+	{OFFSET(mii1_txd0), MODE(2)},			/* RGMII1_TD0 */
+	{OFFSET(mii1_txclk), MODE(2)},			/* RGMII1_TCLK */
+	{OFFSET(mii1_rxclk), MODE(2) | RXACTIVE},	/* RGMII1_RCLK */
+	{OFFSET(mii1_rxd3), MODE(2) | RXACTIVE},	/* RGMII1_RD3 */
+	{OFFSET(mii1_rxd2), MODE(2) | RXACTIVE},	/* RGMII1_RD2 */
+	{OFFSET(mii1_rxd1), MODE(2) | RXACTIVE},	/* RGMII1_RD1 */
+	{OFFSET(mii1_rxd0), MODE(2) | RXACTIVE},	/* RGMII1_RD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN},/* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux mii1_pin_mux[] = {
+	{OFFSET(mii1_rxerr), MODE(0) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(0)},			/* MII1_TXEN */
+	{OFFSET(mii1_rxdv), MODE(0) | RXACTIVE},	/* MII1_RXDV */
+	{OFFSET(mii1_txd3), MODE(0)},			/* MII1_TXD3 */
+	{OFFSET(mii1_txd2), MODE(0)},			/* MII1_TXD2 */
+	{OFFSET(mii1_txd1), MODE(0)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(0)},			/* MII1_TXD0 */
+	{OFFSET(mii1_txclk), MODE(0) | RXACTIVE},	/* MII1_TXCLK */
+	{OFFSET(mii1_rxclk), MODE(0) | RXACTIVE},	/* MII1_RXCLK */
+	{OFFSET(mii1_rxd3), MODE(0) | RXACTIVE},	/* MII1_RXD3 */
+	{OFFSET(mii1_rxd2), MODE(0) | RXACTIVE},	/* MII1_RXD2 */
+	{OFFSET(mii1_rxd1), MODE(0) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(0) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux rmii1_pin_mux[] = {
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mii1_crs), MODE(1) | RXACTIVE},		/* MII1_CRS */
+	{OFFSET(mii1_rxerr), MODE(1) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(1)},			/* MII1_TXEN */
+	{OFFSET(mii1_txd1), MODE(1)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(1)},			/* MII1_TXD0 */
+	{OFFSET(mii1_rxd1), MODE(1) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(1) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(rmii1_refclk), MODE(0) | RXACTIVE},	/* RMII1_REFCLK */
+	{-1},
+};
+
+
+#if 0 // preitinger - da unten von kurz uebernommene definition in jedem fall definiert wird... (wir haben keine boards ohne nand)
+#ifdef CONFIG_NAND
+static struct module_pin_mux nand_pin_mux[] = {
+	{OFFSET(gpmc_ad0),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD0  */
+	{OFFSET(gpmc_ad1),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD1  */
+	{OFFSET(gpmc_ad2),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD2  */
+	{OFFSET(gpmc_ad3),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD3  */
+	{OFFSET(gpmc_ad4),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD4  */
+	{OFFSET(gpmc_ad5),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD5  */
+	{OFFSET(gpmc_ad6),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD6  */
+	{OFFSET(gpmc_ad7),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD7  */
+#ifdef CONFIG_SYS_NAND_BUSWIDTH_16BIT
+	{OFFSET(gpmc_ad8),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD8  */
+	{OFFSET(gpmc_ad9),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD9  */
+	{OFFSET(gpmc_ad10),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD10 */
+	{OFFSET(gpmc_ad11),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD11 */
+	{OFFSET(gpmc_ad12),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD12 */
+	{OFFSET(gpmc_ad13),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD13 */
+	{OFFSET(gpmc_ad14),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD14 */
+	{OFFSET(gpmc_ad15),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD15 */
+#endif
+	{OFFSET(gpmc_wait0),	(MODE(0) | PULLUP_EN | RXACTIVE)}, /* nWAIT */
+	{OFFSET(gpmc_wpn),	(MODE(7) | PULLUP_EN)},		   /* nWP */
+	{OFFSET(gpmc_csn0),	(MODE(0) | PULLUP_EN)},		   /* nCS */
+	{OFFSET(gpmc_wen),	(MODE(0) | PULLDOWN_EN)},	   /* WEN */
+	{OFFSET(gpmc_oen_ren),	(MODE(0) | PULLDOWN_EN)},	   /* OE */
+	{OFFSET(gpmc_advn_ale),	(MODE(0) | PULLDOWN_EN)},	   /* ADV_ALE */
+	{OFFSET(gpmc_be0n_cle),	(MODE(0) | PULLDOWN_EN)},	   /* BE_CLE */
+	{-1},
+};
+#elif defined(CONFIG_NOR)
+static struct module_pin_mux bone_norcape_pin_mux[] = {
+	{OFFSET(gpmc_a0), MODE(0) | PULLUDDIS},			/* NOR_A0 */
+	{OFFSET(gpmc_a1), MODE(0) | PULLUDDIS},			/* NOR_A1 */
+	{OFFSET(gpmc_a2), MODE(0) | PULLUDDIS},			/* NOR_A2 */
+	{OFFSET(gpmc_a3), MODE(0) | PULLUDDIS},			/* NOR_A3 */
+	{OFFSET(gpmc_a4), MODE(0) | PULLUDDIS},			/* NOR_A4 */
+	{OFFSET(gpmc_a5), MODE(0) | PULLUDDIS},			/* NOR_A5 */
+	{OFFSET(gpmc_a6), MODE(0) | PULLUDDIS},			/* NOR_A6 */
+	{OFFSET(gpmc_a7), MODE(0) | PULLUDDIS},			/* NOR_A7 */
+	{OFFSET(gpmc_ad0), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD0 */
+	{OFFSET(gpmc_ad1), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD1 */
+	{OFFSET(gpmc_ad2), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD2 */
+	{OFFSET(gpmc_ad3), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD3 */
+	{OFFSET(gpmc_ad4), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD4 */
+	{OFFSET(gpmc_ad5), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD5 */
+	{OFFSET(gpmc_ad6), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD6 */
+	{OFFSET(gpmc_ad7), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD7 */
+	{OFFSET(gpmc_ad8), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD8 */
+	{OFFSET(gpmc_ad9), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD9 */
+	{OFFSET(gpmc_ad10), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD10 */
+	{OFFSET(gpmc_ad11), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD11 */
+	{OFFSET(gpmc_ad12), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD12 */
+	{OFFSET(gpmc_ad13), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD13 */
+	{OFFSET(gpmc_ad14), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD14 */
+	{OFFSET(gpmc_ad15), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD15 */
+	{OFFSET(gpmc_csn0), MODE(0) | PULLUDEN | PULLUP_EN},     /* CE */
+	{OFFSET(gpmc_advn_ale), MODE(0) | PULLUDEN | PULLDOWN_EN}, /* ALE */
+	{OFFSET(gpmc_oen_ren), MODE(0) | PULLUDEN | PULLDOWN_EN},/* OEn_REN */
+	{OFFSET(gpmc_be0n_cle), MODE(0) | PULLUDEN | PULLDOWN_EN},/* unused */
+	{OFFSET(gpmc_wen), MODE(0) | PULLUDEN | PULLDOWN_EN},    /* WEN */
+	{OFFSET(gpmc_wait0), MODE(0) | PULLUDEN | PULLUP_EN | RXACTIVE},/*WAIT*/
+	{-1},
+};
+#endif
+
+#endif // preitinger - da unten von kurz uebernommene definition in jedem fall definiert wird... (wir haben keine boards ohne nand)
+
+
+static struct module_pin_mux uart3_icev2_pin_mux[] = {
+	{OFFSET(mii1_rxd3), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART3_RXD */
+	{OFFSET(mii1_rxd2), MODE(1) | PULLUDEN},		/* UART3_TXD */
+	{-1},
+};
+
+#if defined(CONFIG_NOR_BOOT)
+void enable_norboot_pin_mux(void)
+{
+	configure_module_pin_mux(bone_norcape_pin_mux);
+}
+#endif
+
+void enable_uart0_pin_mux(void)
+{
+	configure_module_pin_mux(uart0_pin_mux);
+}
+
+void enable_uart1_pin_mux(void)
+{
+	configure_module_pin_mux(uart1_pin_mux);
+}
+
+void enable_uart2_pin_mux(void)
+{
+	configure_module_pin_mux(uart2_pin_mux);
+}
+
+void enable_uart3_pin_mux(void)
+{
+	configure_module_pin_mux(uart3_pin_mux);
+}
+
+void enable_uart4_pin_mux(void)
+{
+	configure_module_pin_mux(uart4_pin_mux);
+}
+
+void enable_uart5_pin_mux(void)
+{
+	configure_module_pin_mux(uart5_pin_mux);
+}
+
+void enable_i2c0_pin_mux(void)
+{
+	configure_module_pin_mux(i2c0_pin_mux);
+}
+
+void enable_i2c2_pin_mux(void)
+{
+	configure_module_pin_mux(i2c2_pin_mux);
+}
+
+/*
+ * The AM335x GP EVM, if daughter card(s) are connected, can have 8
+ * different profiles.  These profiles determine what peripherals are
+ * valid and need pinmux to be configured.
+ */
+#define PROFILE_NONE	0x0
+#define PROFILE_0	(1 << 0)
+#define PROFILE_1	(1 << 1)
+#define PROFILE_2	(1 << 2)
+#define PROFILE_3	(1 << 3)
+#define PROFILE_4	(1 << 4)
+#define PROFILE_5	(1 << 5)
+#define PROFILE_6	(1 << 6)
+#define PROFILE_7	(1 << 7)
+#define PROFILE_MASK	0x7
+#define PROFILE_ALL	0xFF
+
+/* CPLD registers */
+#define I2C_CPLD_ADDR	0x35
+#define CFG_REG		0x10
+
+static unsigned short detect_daughter_board_profile(void)
+{
+	unsigned short val;
+
+#ifndef CONFIG_DM_I2C
+	if (i2c_probe(I2C_CPLD_ADDR))
+		return PROFILE_NONE;
+
+	if (i2c_read(I2C_CPLD_ADDR, CFG_REG, 1, (unsigned char *)(&val), 2))
+		return PROFILE_NONE;
+#else
+	struct udevice *dev = NULL;
+	int rc;
+
+	rc = i2c_get_chip_for_busnum(0, I2C_CPLD_ADDR, 1, &dev);
+	if (rc)
+		return PROFILE_NONE;
+	rc = dm_i2c_read(dev, CFG_REG, (unsigned char *)(&val), 2);
+	if (rc)
+		return PROFILE_NONE;
+#endif
+	return (1 << (val & PROFILE_MASK));
+}
+
+static struct module_pin_mux nand_pin_mux[] = {
+        {OFFSET(gpmc_ad0), (MODE(0) | PULLUP_EN | RXACTIVE)},   /* NAND AD0 */
+        {OFFSET(gpmc_ad1), (MODE(0) | PULLUP_EN | RXACTIVE)},   /* NAND AD1 */
+        {OFFSET(gpmc_ad2), (MODE(0) | PULLUP_EN | RXACTIVE)},   /* NAND AD2 */
+        {OFFSET(gpmc_ad3), (MODE(0) | PULLUP_EN | RXACTIVE)},   /* NAND AD3 */
+        {OFFSET(gpmc_ad4), (MODE(0) | PULLUP_EN | RXACTIVE)},   /* NAND AD4 */
+        {OFFSET(gpmc_ad5), (MODE(0) | PULLUP_EN | RXACTIVE)},   /* NAND AD5 */
+        {OFFSET(gpmc_ad6), (MODE(0) | PULLUP_EN | RXACTIVE)},   /* NAND AD6 */
+        {OFFSET(gpmc_ad7), (MODE(0) | PULLUP_EN | RXACTIVE)},   /* NAND AD7 */
+        {OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUP_EN)}, /* NAND WAIT */
+        {OFFSET(gpmc_wpn), (MODE(7) | PULLUP_EN | RXACTIVE)},   /* NAND_WPN */
+        {OFFSET(gpmc_csn0), (MODE(0) | PULLUDEN)},      /* NAND_CS0 */
+        {OFFSET(gpmc_advn_ale), (MODE(0) | PULLUDEN)}, /* NAND_ADV_ALE */
+        {OFFSET(gpmc_oen_ren), (MODE(0) | PULLUDEN)},   /* NAND_OE */
+        {OFFSET(gpmc_wen), (MODE(0) | PULLUDEN)},       /* NAND_WEN */
+        {OFFSET(gpmc_be0n_cle), (MODE(0) | PULLUDEN)},  /* NAND_BE_CLE */
+        {-1},
+};
+
+void enable_board_pin_mux(void)
+{
+#if 0
+	/* Do board-specific muxes. */
+	if (board_is_beaglelogic()) {
+		/* BeagleLogic pinmux */
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+	} else if (board_is_bone()) {
+		/* Beaglebone pinmux */
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+#if defined(CONFIG_NAND)
+		configure_module_pin_mux(nand_pin_mux);
+#elif defined(CONFIG_NOR)
+		configure_module_pin_mux(bone_norcape_pin_mux);
+#else
+		configure_module_pin_mux(mmc1_pin_mux);
+#endif
+		configure_module_pin_mux(i2c2_pin_mux);
+	} else if (board_is_gp_evm()) {
+		/* General Purpose EVM */
+		unsigned short profile = detect_daughter_board_profile();
+		configure_module_pin_mux(rgmii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+		/* In profile #2 i2c1 and spi0 conflict. */
+		if (profile & ~PROFILE_2)
+			configure_module_pin_mux(i2c1_pin_mux);
+		/* Profiles 2 & 3 don't have NAND */
+#ifdef CONFIG_NAND
+		if (profile & ~(PROFILE_2 | PROFILE_3))
+			configure_module_pin_mux(nand_pin_mux);
+#endif
+		else if (profile == PROFILE_2) {
+			configure_module_pin_mux(mmc1_pin_mux);
+			configure_module_pin_mux(spi0_pin_mux);
+		}
+	} else if (board_is_idk()) {
+		/* Industrial Motor Control (IDK) */
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_no_cd_pin_mux);
+	} else if (board_is_evm_sk()) {
+		/* Starter Kit EVM */
+		configure_module_pin_mux(i2c1_pin_mux);
+		configure_module_pin_mux(gpio0_7_pin_mux);
+		configure_module_pin_mux(rgmii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux_sk_evm);
+	} else if (board_is_bone_lt()) {
+		if (board_is_bben() || board_is_m10a()) {
+			/* SanCloud Beaglebone LT Enhanced pinmux */
+			configure_module_pin_mux(rgmii1_pin_mux);
+		} else {
+			/* Beaglebone LT pinmux */
+			configure_module_pin_mux(mii1_pin_mux);
+		}
+		configure_module_pin_mux(mmc0_pin_mux);
+#if defined(CONFIG_NAND) && defined(CONFIG_EMMC_BOOT)
+		configure_module_pin_mux(nand_pin_mux);
+#elif defined(CONFIG_NOR) && defined(CONFIG_EMMC_BOOT)
+		configure_module_pin_mux(bone_norcape_pin_mux);
+#else
+		configure_module_pin_mux(mmc1_pin_mux);
+#endif
+		configure_module_pin_mux(i2c2_pin_mux);
+	} else if (board_is_pb()) {
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+	} else if (board_is_icev2()) {
+		configure_module_pin_mux(mmc0_pin_mux);
+		configure_module_pin_mux(gpio0_18_pin_mux);
+		configure_module_pin_mux(uart3_icev2_pin_mux);
+		configure_module_pin_mux(rmii1_pin_mux);
+		configure_module_pin_mux(spi0_pin_mux);
+	} else {
+		/* Unknown board. We might still be able to boot. */
+		puts("Bad EEPROM or unknown board, cannot configure pinmux.");
+	}
+#endif
+
+	// TODO begin komplett neu einfach starr
+//	configure_module_pin_mux(nand_pin_mux);
+	configure_module_pin_mux(mii1_pin_mux);
+	configure_module_pin_mux(mmc0_pin_mux);
+//	configure_module_pin_mux(spi0_pin_mux);
+	// TODO end komplett neu einfach starr
+
+	configure_module_pin_mux(nand_pin_mux);
+}
diff --color -rupN uboot-2019.04/cmd/nvedit.c uboot.b/cmd/nvedit.c
--- uboot-2019.04/cmd/nvedit.c	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/cmd/nvedit.c	2020-12-14 08:41:59.996810263 +0100
@@ -666,7 +666,9 @@ static int do_env_edit(cmd_tbl_t *cmdtp,
  */
 char *env_get(const char *name)
 {
+//	printf("preitinger: nvedit.c: env_get - name=%s; gd->flags=%d\n", name, (int)gd->flags);
 	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
+//		printf("preitinger: env_get: if 1\n");
 		ENTRY e, *ep;
 
 		WATCHDOG_RESET();
@@ -679,8 +681,10 @@ char *env_get(const char *name)
 	}
 
 	/* restricted capabilities before import */
-	if (env_get_f(name, (char *)(gd->env_buf), sizeof(gd->env_buf)) > 0)
+	if (env_get_f(name, (char *)(gd->env_buf), sizeof(gd->env_buf)) > 0) {
+//		printf("preitinger: env_get: if 2\n");
 		return (char *)(gd->env_buf);
+	}
 
 	return NULL;
 }
@@ -725,6 +729,7 @@ int env_get_f(const char *name, char *bu
 		return n;
 	}
 
+//	printf("preitinger: env_get_f -1 at end\n");
 	return -1;
 }
 
diff --color -rupN uboot-2019.04/common/spl/spl.c uboot.b/common/spl/spl.c
--- uboot-2019.04/common/spl/spl.c	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/common/spl/spl.c	2020-12-14 08:42:24.060901986 +0100
@@ -23,6 +23,8 @@
 #include <fdt_support.h>
 #include <bootcount.h>
 
+#include "PR.h"
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #ifndef CONFIG_SYS_UBOOT_START
@@ -229,17 +231,22 @@ static int spl_load_fit_image(struct spl
 int spl_parse_image_header(struct spl_image_info *spl_image,
 			   const struct image_header *header)
 {
+	PRE1("begin\n");
 #ifdef CONFIG_SPL_LOAD_FIT_FULL
+#warning CONFIG_SPL_LOAD_FIT_FULL defined
 	int ret = spl_load_fit_image(spl_image, header);
 
 	if (!ret)
 		return ret;
 #endif
 	if (image_get_magic(header) == IH_MAGIC) {
-#ifdef CONFIG_SPL_LEGACY_IMAGE_SUPPORT
+		PRE1("IH_MAGIC found\n");
+#ifdef CONFIG_SPL_LEGACY_IMAGE_SUPPORT // ja
+#warning CONFIG_SPL_LEGACY_IMAGE_SUPPORT defined
 		u32 header_size = sizeof(struct image_header);
 
 #ifdef CONFIG_SPL_LEGACY_IMAGE_CRC_CHECK
+#warning CONFIG_SPL_LEGACY_IMAGE_CRC_CHECK defined
 		/* check uImage header CRC */
 		if (!image_check_hcrc(header)) {
 			puts("SPL: Image header CRC check failed!\n");
@@ -248,6 +255,7 @@ int spl_parse_image_header(struct spl_im
 #endif
 
 		if (spl_image->flags & SPL_COPY_PAYLOAD_ONLY) {
+			PRE1("SPL_COPY_PAYLOAD_ONLY flag set\n");
 			/*
 			 * On some system (e.g. powerpc), the load-address and
 			 * entry-point is located at address 0. We can't load
@@ -257,6 +265,7 @@ int spl_parse_image_header(struct spl_im
 			spl_image->entry_point = image_get_ep(header);
 			spl_image->size = image_get_data_size(header);
 		} else {
+			PRE1("SPL_COPY_PAYLOAD_ONLY flag NOT set\n");
 			spl_image->entry_point = image_get_load(header);
 			/* Load including the header */
 			spl_image->load_addr = spl_image->entry_point -
@@ -283,6 +292,7 @@ int spl_parse_image_header(struct spl_im
 #endif
 	} else {
 #ifdef CONFIG_SPL_PANIC_ON_RAW_IMAGE
+#warning CONFIG_SPL_PANIC_ON_RAW_IMAGE defined
 		/*
 		 * CONFIG_SPL_PANIC_ON_RAW_IMAGE is defined when the
 		 * code which loads images in SPL cannot guarantee that
@@ -311,6 +321,7 @@ int spl_parse_image_header(struct spl_im
 #endif
 
 #ifdef CONFIG_SPL_RAW_IMAGE_SUPPORT
+#warning CONFIG_SPL_RAW_IMAGE_SUPPORT defined // ja
 		/* Signature not found - assume u-boot.bin */
 		debug("mkimage signature not found - ih_magic = %x\n",
 			header->ih_magic);
@@ -322,6 +333,7 @@ int spl_parse_image_header(struct spl_im
 #endif
 	}
 
+	PRE1("return 0 am ende\n");
 	return 0;
 }
 
@@ -518,6 +530,7 @@ static int spl_load_image(struct spl_ima
 
 	ret = loader->load_image(spl_image, &bootdev);
 #ifdef CONFIG_SPL_LEGACY_IMAGE_CRC_CHECK
+	printf("preitinger: ifdef CONFIG_SPL_LEGACY_IMAGE_CRC_CHECK\n");
 	if (!ret && spl_image->dcrc_length) {
 		/* check data crc */
 		ulong dcrc = crc32_wd(0, (unsigned char *)spl_image->dcrc_data,
@@ -528,6 +541,7 @@ static int spl_load_image(struct spl_ima
 		}
 	}
 #endif
+	printf("preitinger: spl_load_image: ret=%d\n", ret);
 	return ret;
 }
 
@@ -544,7 +558,14 @@ static int boot_from_devices(struct spl_
 {
 	int i;
 
+	printf("preitinger: boot_from_devices: count=%d\n", count);
+
 	for (i = 0; i < count && spl_boot_list[i] != BOOT_DEVICE_NONE; i++) {
+		printf("preitinger: boot_from_devices: i=%d\n", i);
+//		if (i == 0) {
+//			printf("preitinger: ueberspringe i==%d\n", i);
+//			continue;
+//		}
 		struct spl_image_loader *loader;
 
 		loader = spl_ll_find_loader(spl_boot_list[i]);
@@ -556,6 +577,7 @@ static int boot_from_devices(struct spl_
 #endif
 		if (loader && !spl_load_image(spl_image, loader)) {
 			spl_image->boot_device = spl_boot_list[i];
+			printf("preitinger: return 0 when i=%d\n", i);
 			return 0;
 		}
 	}
diff --color -rupN uboot-2019.04/common/spl/spl.c~ uboot.b/common/spl/spl.c~
--- uboot-2019.04/common/spl/spl.c~	1970-01-01 01:00:00.000000000 +0100
+++ uboot.b/common/spl/spl.c~	2020-12-14 08:42:24.060901986 +0100
@@ -0,0 +1,756 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2010
+ * Texas Instruments, <www.ti.com>
+ *
+ * Aneesh V <aneesh@ti.com>
+ */
+
+#include <common.h>
+#include <bloblist.h>
+#include <binman_sym.h>
+#include <dm.h>
+#include <handoff.h>
+#include <spl.h>
+#include <asm/u-boot.h>
+#include <nand.h>
+#include <fat.h>
+#include <version.h>
+#include <image.h>
+#include <malloc.h>
+#include <dm/root.h>
+#include <linux/compiler.h>
+#include <fdt_support.h>
+#include <bootcount.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_SYS_UBOOT_START
+#define CONFIG_SYS_UBOOT_START	CONFIG_SYS_TEXT_BASE
+#endif
+#ifndef CONFIG_SYS_MONITOR_LEN
+/* Unknown U-Boot size, let's assume it will not be more than 200 KB */
+#define CONFIG_SYS_MONITOR_LEN	(200 * 1024)
+#endif
+
+u32 *boot_params_ptr = NULL;
+
+/* See spl.h for information about this */
+binman_sym_declare(ulong, u_boot_any, image_pos);
+
+/* Define board data structure */
+static bd_t bdata __attribute__ ((section(".data")));
+
+/*
+ * Board-specific Platform code can reimplement show_boot_progress () if needed
+ */
+__weak void show_boot_progress(int val) {}
+
+#if defined(CONFIG_SPL_OS_BOOT) || CONFIG_IS_ENABLED(HANDOFF)
+/* weak, default platform-specific function to initialize dram banks */
+__weak int dram_init_banksize(void)
+{
+	return 0;
+}
+#endif
+
+/*
+ * Default function to determine if u-boot or the OS should
+ * be started. This implementation always returns 1.
+ *
+ * Please implement your own board specific funcion to do this.
+ *
+ * RETURN
+ * 0 to not start u-boot
+ * positive if u-boot should start
+ */
+#ifdef CONFIG_SPL_OS_BOOT
+__weak int spl_start_uboot(void)
+{
+	puts(SPL_TPL_PROMPT
+	     "Please implement spl_start_uboot() for your board\n");
+	puts(SPL_TPL_PROMPT "Direct Linux boot not active!\n");
+	return 1;
+}
+
+/*
+ * Weak default function for arch specific zImage check. Return zero
+ * and fill start and end address if image is recognized.
+ */
+int __weak bootz_setup(ulong image, ulong *start, ulong *end)
+{
+	 return 1;
+}
+#endif
+
+/* Weak default function for arch/board-specific fixups to the spl_image_info */
+void __weak spl_perform_fixups(struct spl_image_info *spl_image)
+{
+}
+
+void spl_fixup_fdt(void)
+{
+#if defined(CONFIG_SPL_OF_LIBFDT) && defined(CONFIG_SYS_SPL_ARGS_ADDR)
+	void *fdt_blob = (void *)CONFIG_SYS_SPL_ARGS_ADDR;
+	int err;
+
+	err = fdt_check_header(fdt_blob);
+	if (err < 0) {
+		printf("fdt_root: %s\n", fdt_strerror(err));
+		return;
+	}
+
+	/* fixup the memory dt node */
+	err = fdt_shrink_to_minimum(fdt_blob, 0);
+	if (err == 0) {
+		printf(SPL_TPL_PROMPT "fdt_shrink_to_minimum err - %d\n", err);
+		return;
+	}
+
+	err = arch_fixup_fdt(fdt_blob);
+	if (err) {
+		printf(SPL_TPL_PROMPT "arch_fixup_fdt err - %d\n", err);
+		return;
+	}
+#endif
+}
+
+/*
+ * Weak default function for board specific cleanup/preparation before
+ * Linux boot. Some boards/platforms might not need it, so just provide
+ * an empty stub here.
+ */
+__weak void spl_board_prepare_for_linux(void)
+{
+	/* Nothing to do! */
+}
+
+__weak void spl_board_prepare_for_boot(void)
+{
+	/* Nothing to do! */
+}
+
+__weak struct image_header *spl_get_load_buffer(ssize_t offset, size_t size)
+{
+	return (struct image_header *)(CONFIG_SYS_TEXT_BASE + offset);
+}
+
+void spl_set_header_raw_uboot(struct spl_image_info *spl_image)
+{
+	ulong u_boot_pos = binman_sym(ulong, u_boot_any, image_pos);
+
+	spl_image->size = CONFIG_SYS_MONITOR_LEN;
+
+	/*
+	 * Binman error cases: address of the end of the previous region or the
+	 * start of the image's entry area (usually 0) if there is no previous
+	 * region.
+	 */
+	if (u_boot_pos && u_boot_pos != BINMAN_SYM_MISSING) {
+		/* Binman does not support separated entry addresses */
+		spl_image->entry_point = u_boot_pos;
+		spl_image->load_addr = u_boot_pos;
+	} else {
+		spl_image->entry_point = CONFIG_SYS_UBOOT_START;
+		spl_image->load_addr = CONFIG_SYS_TEXT_BASE;
+	}
+	spl_image->os = IH_OS_U_BOOT;
+	spl_image->name = "U-Boot";
+}
+
+#ifdef CONFIG_SPL_LOAD_FIT_FULL
+/* Parse and load full fitImage in SPL */
+static int spl_load_fit_image(struct spl_image_info *spl_image,
+			      const struct image_header *header)
+{
+	bootm_headers_t images;
+	const char *fit_uname_config = NULL;
+	const char *fit_uname_fdt = FIT_FDT_PROP;
+	const char *uname;
+	ulong fw_data = 0, dt_data = 0, img_data = 0;
+	ulong fw_len = 0, dt_len = 0, img_len = 0;
+	int idx, conf_noffset;
+	int ret;
+
+#ifdef CONFIG_SPL_FIT_SIGNATURE
+	images.verify = 1;
+#endif
+	ret = fit_image_load(&images, (ulong)header,
+			     NULL, &fit_uname_config,
+			     IH_ARCH_DEFAULT, IH_TYPE_STANDALONE, -1,
+			     FIT_LOAD_REQUIRED, &fw_data, &fw_len);
+	if (ret < 0)
+		return ret;
+
+	spl_image->size = fw_len;
+	spl_image->entry_point = fw_data;
+	spl_image->load_addr = fw_data;
+	spl_image->os = IH_OS_U_BOOT;
+	spl_image->name = "U-Boot";
+
+	debug(SPL_TPL_PROMPT "payload image: %32s load addr: 0x%lx size: %d\n",
+	      spl_image->name, spl_image->load_addr, spl_image->size);
+
+#ifdef CONFIG_SPL_FIT_SIGNATURE
+	images.verify = 1;
+#endif
+	fit_image_load(&images, (ulong)header,
+		       &fit_uname_fdt, &fit_uname_config,
+		       IH_ARCH_DEFAULT, IH_TYPE_FLATDT, -1,
+		       FIT_LOAD_OPTIONAL, &dt_data, &dt_len);
+
+	conf_noffset = fit_conf_get_node((const void *)header,
+					 fit_uname_config);
+	if (conf_noffset <= 0)
+		return 0;
+
+	for (idx = 0;
+	     uname = fdt_stringlist_get((const void *)header, conf_noffset,
+					FIT_LOADABLE_PROP, idx,
+				NULL), uname;
+	     idx++)
+	{
+#ifdef CONFIG_SPL_FIT_SIGNATURE
+		images.verify = 1;
+#endif
+		ret = fit_image_load(&images, (ulong)header,
+				     &uname, &fit_uname_config,
+				     IH_ARCH_DEFAULT, IH_TYPE_LOADABLE, -1,
+				     FIT_LOAD_OPTIONAL_NON_ZERO,
+				     &img_data, &img_len);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+#endif
+
+int spl_parse_image_header(struct spl_image_info *spl_image,
+			   const struct image_header *header)
+{
+#ifdef CONFIG_SPL_LOAD_FIT_FULL
+	int ret = spl_load_fit_image(spl_image, header);
+
+	if (!ret)
+		return ret;
+#endif
+	if (image_get_magic(header) == IH_MAGIC) {
+#ifdef CONFIG_SPL_LEGACY_IMAGE_SUPPORT
+		u32 header_size = sizeof(struct image_header);
+
+#ifdef CONFIG_SPL_LEGACY_IMAGE_CRC_CHECK
+		/* check uImage header CRC */
+		if (!image_check_hcrc(header)) {
+			puts("SPL: Image header CRC check failed!\n");
+			return -EINVAL;
+		}
+#endif
+
+		if (spl_image->flags & SPL_COPY_PAYLOAD_ONLY) {
+			/*
+			 * On some system (e.g. powerpc), the load-address and
+			 * entry-point is located at address 0. We can't load
+			 * to 0-0x40. So skip header in this case.
+			 */
+			spl_image->load_addr = image_get_load(header);
+			spl_image->entry_point = image_get_ep(header);
+			spl_image->size = image_get_data_size(header);
+		} else {
+			spl_image->entry_point = image_get_load(header);
+			/* Load including the header */
+			spl_image->load_addr = spl_image->entry_point -
+				header_size;
+			spl_image->size = image_get_data_size(header) +
+				header_size;
+		}
+#ifdef CONFIG_SPL_LEGACY_IMAGE_CRC_CHECK
+		/* store uImage data length and CRC to check later */
+		spl_image->dcrc_data = image_get_load(header);
+		spl_image->dcrc_length = image_get_data_size(header);
+		spl_image->dcrc = image_get_dcrc(header);
+#endif
+
+		spl_image->os = image_get_os(header);
+		spl_image->name = image_get_name(header);
+		debug(SPL_TPL_PROMPT
+		      "payload image: %32s load addr: 0x%lx size: %d\n",
+		      spl_image->name, spl_image->load_addr, spl_image->size);
+#else
+		/* LEGACY image not supported */
+		debug("Legacy boot image support not enabled, proceeding to other boot methods\n");
+		return -EINVAL;
+#endif
+	} else {
+#ifdef CONFIG_SPL_PANIC_ON_RAW_IMAGE
+		/*
+		 * CONFIG_SPL_PANIC_ON_RAW_IMAGE is defined when the
+		 * code which loads images in SPL cannot guarantee that
+		 * absolutely all read errors will be reported.
+		 * An example is the LPC32XX MLC NAND driver, which
+		 * will consider that a completely unreadable NAND block
+		 * is bad, and thus should be skipped silently.
+		 */
+		panic("** no mkimage signature but raw image not supported");
+#endif
+
+#ifdef CONFIG_SPL_OS_BOOT
+		ulong start, end;
+
+		if (!bootz_setup((ulong)header, &start, &end)) {
+			spl_image->name = "Linux";
+			spl_image->os = IH_OS_LINUX;
+			spl_image->load_addr = CONFIG_SYS_LOAD_ADDR;
+			spl_image->entry_point = CONFIG_SYS_LOAD_ADDR;
+			spl_image->size = end - start;
+			debug(SPL_TPL_PROMPT
+			      "payload zImage, load addr: 0x%lx size: %d\n",
+			      spl_image->load_addr, spl_image->size);
+			return 0;
+		}
+#endif
+
+#ifdef CONFIG_SPL_RAW_IMAGE_SUPPORT
+		/* Signature not found - assume u-boot.bin */
+		debug("mkimage signature not found - ih_magic = %x\n",
+			header->ih_magic);
+		spl_set_header_raw_uboot(spl_image);
+#else
+		/* RAW image not supported, proceed to other boot methods. */
+		debug("Raw boot image support not enabled, proceeding to other boot methods\n");
+		return -EINVAL;
+#endif
+	}
+
+	return 0;
+}
+
+__weak void __noreturn jump_to_image_no_args(struct spl_image_info *spl_image)
+{
+	typedef void __noreturn (*image_entry_noargs_t)(void);
+
+	image_entry_noargs_t image_entry =
+		(image_entry_noargs_t)spl_image->entry_point;
+
+	debug("image entry point: 0x%lx\n", spl_image->entry_point);
+	image_entry();
+}
+
+#if CONFIG_IS_ENABLED(HANDOFF)
+/**
+ * Set up the SPL hand-off information
+ *
+ * This is initially empty (zero) but can be written by
+ */
+static int setup_spl_handoff(void)
+{
+	struct spl_handoff *ho;
+
+	ho = bloblist_ensure(BLOBLISTT_SPL_HANDOFF, sizeof(struct spl_handoff));
+	if (!ho)
+		return -ENOENT;
+
+	return 0;
+}
+
+static int write_spl_handoff(void)
+{
+	struct spl_handoff *ho;
+
+	ho = bloblist_find(BLOBLISTT_SPL_HANDOFF, sizeof(struct spl_handoff));
+	if (!ho)
+		return -ENOENT;
+	handoff_save_dram(ho);
+#ifdef CONFIG_SANDBOX
+	ho->arch.magic = TEST_HANDOFF_MAGIC;
+#endif
+	debug(SPL_TPL_PROMPT "Wrote SPL handoff\n");
+
+	return 0;
+}
+#else
+static inline int setup_spl_handoff(void) { return 0; }
+static inline int write_spl_handoff(void) { return 0; }
+
+#endif /* HANDOFF */
+
+static int spl_common_init(bool setup_malloc)
+{
+	int ret;
+
+#if CONFIG_VAL(SYS_MALLOC_F_LEN)
+	if (setup_malloc) {
+#ifdef CONFIG_MALLOC_F_ADDR
+		gd->malloc_base = CONFIG_MALLOC_F_ADDR;
+#endif
+		gd->malloc_limit = CONFIG_VAL(SYS_MALLOC_F_LEN);
+		gd->malloc_ptr = 0;
+	}
+#endif
+	ret = bootstage_init(true);
+	if (ret) {
+		debug("%s: Failed to set up bootstage: ret=%d\n", __func__,
+		      ret);
+		return ret;
+	}
+	bootstage_mark_name(BOOTSTAGE_ID_START_SPL, "spl");
+#if CONFIG_IS_ENABLED(LOG)
+	ret = log_init();
+	if (ret) {
+		debug("%s: Failed to set up logging\n", __func__);
+		return ret;
+	}
+#endif
+	if (CONFIG_IS_ENABLED(BLOBLIST)) {
+		ret = bloblist_init();
+		if (ret) {
+			debug("%s: Failed to set up bloblist: ret=%d\n",
+			      __func__, ret);
+			return ret;
+		}
+	}
+	if (CONFIG_IS_ENABLED(HANDOFF)) {
+		int ret;
+
+		ret = setup_spl_handoff();
+		if (ret) {
+			puts(SPL_TPL_PROMPT "Cannot set up SPL handoff\n");
+			hang();
+		}
+	}
+	if (CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)) {
+		ret = fdtdec_setup();
+		if (ret) {
+			debug("fdtdec_setup() returned error %d\n", ret);
+			return ret;
+		}
+	}
+	if (CONFIG_IS_ENABLED(DM)) {
+		bootstage_start(BOOTSTATE_ID_ACCUM_DM_SPL, "dm_spl");
+		/* With CONFIG_SPL_OF_PLATDATA, bring in all devices */
+		ret = dm_init_and_scan(!CONFIG_IS_ENABLED(OF_PLATDATA));
+		bootstage_accum(BOOTSTATE_ID_ACCUM_DM_SPL);
+		if (ret) {
+			debug("dm_init_and_scan() returned error %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+void spl_set_bd(void)
+{
+	/*
+	 * NOTE: On some platforms (e.g. x86) bdata may be in flash and not
+	 * writeable.
+	 */
+	if (!gd->bd)
+		gd->bd = &bdata;
+}
+
+int spl_early_init(void)
+{
+	int ret;
+
+	debug("%s\n", __func__);
+
+	ret = spl_common_init(true);
+	if (ret)
+		return ret;
+	gd->flags |= GD_FLG_SPL_EARLY_INIT;
+
+	return 0;
+}
+
+int spl_init(void)
+{
+	int ret;
+	bool setup_malloc = !(IS_ENABLED(CONFIG_SPL_STACK_R) &&
+			IS_ENABLED(CONFIG_SPL_SYS_MALLOC_SIMPLE));
+
+	debug("%s\n", __func__);
+
+	if (!(gd->flags & GD_FLG_SPL_EARLY_INIT)) {
+		ret = spl_common_init(setup_malloc);
+		if (ret)
+			return ret;
+	}
+	gd->flags |= GD_FLG_SPL_INIT;
+
+	return 0;
+}
+
+#ifndef BOOT_DEVICE_NONE
+#define BOOT_DEVICE_NONE 0xdeadbeef
+#endif
+
+__weak void board_boot_order(u32 *spl_boot_list)
+{
+	spl_boot_list[0] = spl_boot_device();
+}
+
+static struct spl_image_loader *spl_ll_find_loader(uint boot_device)
+{
+	struct spl_image_loader *drv =
+		ll_entry_start(struct spl_image_loader, spl_image_loader);
+	const int n_ents =
+		ll_entry_count(struct spl_image_loader, spl_image_loader);
+	struct spl_image_loader *entry;
+
+	for (entry = drv; entry != drv + n_ents; entry++) {
+		if (boot_device == entry->boot_device)
+			return entry;
+	}
+
+	/* Not found */
+	return NULL;
+}
+
+static int spl_load_image(struct spl_image_info *spl_image,
+			  struct spl_image_loader *loader)
+{
+	int ret;
+	struct spl_boot_device bootdev;
+
+	bootdev.boot_device = loader->boot_device;
+	bootdev.boot_device_name = NULL;
+
+	ret = loader->load_image(spl_image, &bootdev);
+#ifdef CONFIG_SPL_LEGACY_IMAGE_CRC_CHECK
+	if (!ret && spl_image->dcrc_length) {
+		/* check data crc */
+		ulong dcrc = crc32_wd(0, (unsigned char *)spl_image->dcrc_data,
+				      spl_image->dcrc_length, CHUNKSZ_CRC32);
+		if (dcrc != spl_image->dcrc) {
+			puts("SPL: Image data CRC check failed!\n");
+			ret = -EINVAL;
+		}
+	}
+#endif
+	return ret;
+}
+
+/**
+ * boot_from_devices() - Try loading an booting U-Boot from a list of devices
+ *
+ * @spl_image: Place to put the image details if successful
+ * @spl_boot_list: List of boot devices to try
+ * @count: Number of elements in spl_boot_list
+ * @return 0 if OK, -ve on error
+ */
+static int boot_from_devices(struct spl_image_info *spl_image,
+			     u32 spl_boot_list[], int count)
+{
+	int i;
+
+	printf("preitinger: boot_from_devices: count=%d\n", count);
+
+	for (i = 0; i < count && spl_boot_list[i] != BOOT_DEVICE_NONE; i++) {
+		printf("preitinger: boot_from_devices: i=%d\n", i);
+		struct spl_image_loader *loader;
+
+		loader = spl_ll_find_loader(spl_boot_list[i]);
+#if defined(CONFIG_SPL_SERIAL_SUPPORT) && defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
+		if (loader)
+			printf("Trying to boot from %s\n", loader->name);
+		else
+			puts(SPL_TPL_PROMPT "Unsupported Boot Device!\n");
+#endif
+		if (loader && !spl_load_image(spl_image, loader)) {
+			spl_image->boot_device = spl_boot_list[i];
+			return 0;
+		}
+	}
+
+	return -ENODEV;
+}
+
+void board_init_r(gd_t *dummy1, ulong dummy2)
+{
+	u32 spl_boot_list[] = {
+		BOOT_DEVICE_NONE,
+		BOOT_DEVICE_NONE,
+		BOOT_DEVICE_NONE,
+		BOOT_DEVICE_NONE,
+		BOOT_DEVICE_NONE,
+	};
+	struct spl_image_info spl_image;
+	int ret;
+
+	debug(">>" SPL_TPL_PROMPT "board_init_r()\n");
+
+	spl_set_bd();
+
+#if defined(CONFIG_SYS_SPL_MALLOC_START)
+	mem_malloc_init(CONFIG_SYS_SPL_MALLOC_START,
+			CONFIG_SYS_SPL_MALLOC_SIZE);
+	gd->flags |= GD_FLG_FULL_MALLOC_INIT;
+#endif
+	if (!(gd->flags & GD_FLG_SPL_INIT)) {
+		if (spl_init())
+			hang();
+	}
+#if !defined(CONFIG_PPC) && !defined(CONFIG_ARCH_MX6)
+	/*
+	 * timer_init() does not exist on PPC systems. The timer is initialized
+	 * and enabled (decrementer) in interrupt_init() here.
+	 */
+	timer_init();
+#endif
+
+#if CONFIG_IS_ENABLED(BOARD_INIT)
+	spl_board_init();
+#endif
+
+	if (IS_ENABLED(CONFIG_SPL_OS_BOOT) || CONFIG_IS_ENABLED(HANDOFF))
+		dram_init_banksize();
+
+	bootcount_inc();
+
+	memset(&spl_image, '\0', sizeof(spl_image));
+#ifdef CONFIG_SYS_SPL_ARGS_ADDR
+	spl_image.arg = (void *)CONFIG_SYS_SPL_ARGS_ADDR;
+#endif
+	spl_image.boot_device = BOOT_DEVICE_NONE;
+	board_boot_order(spl_boot_list);
+
+	if (boot_from_devices(&spl_image, spl_boot_list,
+			      ARRAY_SIZE(spl_boot_list))) {
+		puts(SPL_TPL_PROMPT "failed to boot from all boot devices\n");
+		hang();
+	}
+
+	spl_perform_fixups(&spl_image);
+	if (CONFIG_IS_ENABLED(HANDOFF)) {
+		ret = write_spl_handoff();
+		if (ret)
+			printf(SPL_TPL_PROMPT
+			       "SPL hand-off write failed (err=%d)\n", ret);
+	}
+	if (CONFIG_IS_ENABLED(BLOBLIST)) {
+		ret = bloblist_finish();
+		if (ret)
+			printf("Warning: Failed to finish bloblist (ret=%d)\n",
+			       ret);
+	}
+
+#ifdef CONFIG_CPU_V7M
+	spl_image.entry_point |= 0x1;
+#endif
+	switch (spl_image.os) {
+	case IH_OS_U_BOOT:
+		debug("Jumping to U-Boot\n");
+		break;
+#if CONFIG_IS_ENABLED(ATF)
+	case IH_OS_ARM_TRUSTED_FIRMWARE:
+		debug("Jumping to U-Boot via ARM Trusted Firmware\n");
+		spl_invoke_atf(&spl_image);
+		break;
+#endif
+#if CONFIG_IS_ENABLED(OPTEE)
+	case IH_OS_TEE:
+		debug("Jumping to U-Boot via OP-TEE\n");
+		spl_optee_entry(NULL, NULL, spl_image.fdt_addr,
+				(void *)spl_image.entry_point);
+		break;
+#endif
+#ifdef CONFIG_SPL_OS_BOOT
+	case IH_OS_LINUX:
+		debug("Jumping to Linux\n");
+		spl_fixup_fdt();
+		spl_board_prepare_for_linux();
+		jump_to_image_linux(&spl_image);
+#endif
+	default:
+		debug("Unsupported OS image.. Jumping nevertheless..\n");
+	}
+#if CONFIG_VAL(SYS_MALLOC_F_LEN) && !defined(CONFIG_SYS_SPL_MALLOC_SIZE)
+	debug("SPL malloc() used 0x%lx bytes (%ld KB)\n", gd->malloc_ptr,
+	      gd->malloc_ptr / 1024);
+#endif
+#ifdef CONFIG_BOOTSTAGE_STASH
+	bootstage_mark_name(BOOTSTAGE_ID_END_SPL, "end_spl");
+	ret = bootstage_stash((void *)CONFIG_BOOTSTAGE_STASH_ADDR,
+			      CONFIG_BOOTSTAGE_STASH_SIZE);
+	if (ret)
+		debug("Failed to stash bootstage: err=%d\n", ret);
+#endif
+
+	debug("loaded - jumping to U-Boot...\n");
+	spl_board_prepare_for_boot();
+	jump_to_image_no_args(&spl_image);
+}
+
+#ifdef CONFIG_SPL_SERIAL_SUPPORT
+/*
+ * This requires UART clocks to be enabled.  In order for this to work the
+ * caller must ensure that the gd pointer is valid.
+ */
+void preloader_console_init(void)
+{
+	gd->baudrate = CONFIG_BAUDRATE;
+
+	serial_init();		/* serial communications setup */
+
+	gd->have_console = 1;
+
+#if CONFIG_IS_ENABLED(BANNER_PRINT)
+	puts("\nU-Boot " SPL_TPL_NAME " " PLAIN_VERSION " (" U_BOOT_DATE " - "
+	     U_BOOT_TIME " " U_BOOT_TZ ")\n");
+#endif
+#ifdef CONFIG_SPL_DISPLAY_PRINT
+	spl_display_print();
+#endif
+}
+#endif
+
+/**
+ * spl_relocate_stack_gd() - Relocate stack ready for board_init_r() execution
+ *
+ * Sometimes board_init_f() runs with a stack in SRAM but we want to use SDRAM
+ * for the main board_init_r() execution. This is typically because we need
+ * more stack space for things like the MMC sub-system.
+ *
+ * This function calculates the stack position, copies the global_data into
+ * place, sets the new gd (except for ARM, for which setting GD within a C
+ * function may not always work) and returns the new stack position. The
+ * caller is responsible for setting up the sp register and, in the case
+ * of ARM, setting up gd.
+ *
+ * All of this is done using the same layout and alignments as done in
+ * board_init_f_init_reserve() / board_init_f_alloc_reserve().
+ *
+ * @return new stack location, or 0 to use the same stack
+ */
+ulong spl_relocate_stack_gd(void)
+{
+#ifdef CONFIG_SPL_STACK_R
+	gd_t *new_gd;
+	ulong ptr = CONFIG_SPL_STACK_R_ADDR;
+
+#if defined(CONFIG_SPL_SYS_MALLOC_SIMPLE) && CONFIG_VAL(SYS_MALLOC_F_LEN)
+	if (CONFIG_SPL_STACK_R_MALLOC_SIMPLE_LEN) {
+		debug("SPL malloc() before relocation used 0x%lx bytes (%ld KB)\n",
+		      gd->malloc_ptr, gd->malloc_ptr / 1024);
+		ptr -= CONFIG_SPL_STACK_R_MALLOC_SIMPLE_LEN;
+		gd->malloc_base = ptr;
+		gd->malloc_limit = CONFIG_SPL_STACK_R_MALLOC_SIMPLE_LEN;
+		gd->malloc_ptr = 0;
+	}
+#endif
+	/* Get stack position: use 8-byte alignment for ABI compliance */
+	ptr = CONFIG_SPL_STACK_R_ADDR - roundup(sizeof(gd_t),16);
+	new_gd = (gd_t *)ptr;
+	memcpy(new_gd, (void *)gd, sizeof(gd_t));
+#if CONFIG_IS_ENABLED(DM)
+	dm_fixup_for_gd_move(new_gd);
+#endif
+#if !defined(CONFIG_ARM)
+	gd = new_gd;
+#endif
+	return ptr;
+#else
+	return 0;
+#endif
+}
diff --color -rupN uboot-2019.04/common/spl/spl_mmc.c uboot.b/common/spl/spl_mmc.c
--- uboot-2019.04/common/spl/spl_mmc.c	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/common/spl/spl_mmc.c	2020-12-14 08:42:24.060901986 +0100
@@ -14,6 +14,7 @@
 #include <errno.h>
 #include <mmc.h>
 #include <image.h>
+#include <PR.h>
 
 static int mmc_load_legacy(struct spl_image_info *spl_image, struct mmc *mmc,
 			   ulong sector, struct image_header *header)
@@ -22,6 +23,8 @@ static int mmc_load_legacy(struct spl_im
 	unsigned long count;
 	int ret;
 
+	PRE1("preitinger: mmc_load_legacy\n");
+
 	ret = spl_parse_image_header(spl_image, header);
 	if (ret)
 		return ret;
@@ -57,6 +60,8 @@ int mmc_load_image_raw_sector(struct spl
 	struct image_header *header;
 	struct blk_desc *bd = mmc_get_blk_desc(mmc);
 	int ret = 0;
+	printf("preitinger: mmc_load_image_raw_sector\n");
+
 
 	header = spl_get_load_buffer(-sizeof(*header), bd->blksz);
 
@@ -96,6 +101,7 @@ end:
 
 static int spl_mmc_get_device_index(u32 boot_device)
 {
+	printf("preitinger: spl_mmc_get_device_index\n");
 	switch (boot_device) {
 	case BOOT_DEVICE_MMC1:
 		return 0;
diff --color -rupN uboot-2019.04/common/spl/spl_nand.c uboot.b/common/spl/spl_nand.c
--- uboot-2019.04/common/spl/spl_nand.c	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/common/spl/spl_nand.c	2020-12-14 08:42:24.064902002 +0100
@@ -11,6 +11,8 @@
 #include <linux/libfdt_env.h>
 #include <fdt.h>
 
+#include "PR.h"
+
 #if defined(CONFIG_SPL_NAND_RAW_ONLY)
 static int spl_nand_load_image(struct spl_image_info *spl_image,
 			struct spl_boot_device *bootdev)
@@ -76,6 +78,8 @@ static int spl_nand_load_image(struct sp
 	int *src __attribute__((unused));
 	int *dst __attribute__((unused));
 
+	PRE1("begin\n");
+
 #ifdef CONFIG_SPL_NAND_SOFTECC
 	debug("spl: nand - using sw ecc\n");
 #else
@@ -86,7 +90,12 @@ static int spl_nand_load_image(struct sp
 	header = spl_get_load_buffer(0, sizeof(*header));
 
 #ifdef CONFIG_SPL_OS_BOOT
+	PRE1("CONFIG_SPL_OS_BOOT defined\n");
 	if (!spl_start_uboot()) {
+		PRE1("!spl_start_uboot\n");
+
+		char *bootSwitchEnv = env_get("my_boot_switch");
+
 		/*
 		 * load parameter image
 		 * load to temp position since nand_spl_load_image reads
@@ -94,7 +103,9 @@ static int spl_nand_load_image(struct sp
 		 * CONFIG_CMD_SPL_WRITE_SIZE therefore may overwrite
 		 * following sections like BSS
 		 */
-		nand_spl_load_image(CONFIG_CMD_SPL_NAND_OFS,
+		bool bootSwitchEnvIsZero = (!bootSwitchEnv || !strcmp("0", bootSwitchEnv));
+		uint32_t kparams_off = (bootSwitchEnvIsZero ? CONFIG_CV_KPARAMS0_OFFS : CONFIG_CV_KPARAMS1_OFFS);
+		nand_spl_load_image(kparams_off,
 			CONFIG_CMD_SPL_WRITE_SIZE,
 			(void *)CONFIG_SYS_TEXT_BASE);
 		/* copy to destintion */
@@ -107,18 +118,25 @@ static int spl_nand_load_image(struct sp
 		}
 
 		/* load linux */
-		nand_spl_load_image(CONFIG_SYS_NAND_SPL_KERNEL_OFFS,
+		uint32_t kernel_off = ((!bootSwitchEnv || !strcmp("0", bootSwitchEnv)) ? CONFIG_CV_KERNEL0_OFFS : CONFIG_CV_KERNEL1_OFFS);
+		PRE("kernel_off: 0x%x\n", kernel_off);
+		
+		nand_spl_load_image(kernel_off,
 			sizeof(*header), (void *)header);
 		err = spl_parse_image_header(spl_image, header);
+		PRE("nach spl_parse_image_header: err=%d\n", err);
 		if (err)
 			return err;
 		if (header->ih_os == IH_OS_LINUX) {
+			PRE("IH_OS_LINUX: spl_image->size=%d\n", spl_image->size);
 			/* happy - was a linux */
 			err = nand_spl_load_image(
-				CONFIG_SYS_NAND_SPL_KERNEL_OFFS,
+				kernel_off,
 				spl_image->size,
 				(void *)spl_image->load_addr);
+			PRE("nach nand_spl_load_image: err=%d\n", err);
 			nand_deselect();
+			PRE1("nach nand_deselect\n");
 			return err;
 		} else {
 			puts("The Expected Linux image was not "
@@ -135,6 +153,7 @@ static int spl_nand_load_image(struct sp
 #endif
 #endif
 	/* Load u-boot */
+	PRE("[2] CONFIG_SYS_NAND_U_BOOT_OFFS=0x%x\n", CONFIG_SYS_NAND_U_BOOT_OFFS);
 	err = spl_nand_load_element(spl_image, CONFIG_SYS_NAND_U_BOOT_OFFS,
 				    header);
 #ifdef CONFIG_SYS_NAND_U_BOOT_OFFS_REDUND
@@ -146,6 +165,7 @@ static int spl_nand_load_image(struct sp
 #endif
 #endif
 	nand_deselect();
+	PRE("err=%d\n", err);
 	return err;
 }
 #endif
diff --color -rupN uboot-2019.04/configs/cv_kurz_defconfig uboot.b/configs/cv_kurz_defconfig
--- uboot-2019.04/configs/cv_kurz_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ uboot.b/configs/cv_kurz_defconfig	2020-12-14 08:42:23.924901472 +0100
@@ -0,0 +1,81 @@
+CONFIG_ARM=y
+CONFIG_ARCH_OMAP2PLUS=y
+CONFIG_TI_COMMON_CMD_OPTIONS=y
+CONFIG_AM33XX=y
+CONFIG_CV_KERNEL0_OFFS=0x001c0000
+CONFIG_CV_KERNEL1_OFFS=0x009c0000
+CONFIG_CV_KPARAMS0_OFFS=0x011c0000
+CONFIG_CV_KPARAMS1_OFFS=0x01200000
+CONFIG_CV_BOOTCOUNT_LIMIT=3
+CONFIG_SPL=y
+CONFIG_DISTRO_DEFAULTS=y
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_SPL_FIT=y
+CONFIG_NAND_BOOT=y
+CONFIG_SD_BOOT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyO0,115200n8 root=/dev/mmcblk0p2 rw wait rootfstype=ext4 rootwait"
+CONFIG_BOOTCOMMAND="if mmc rescan; then if load mmc 0:1 $loadaddr /boot.scr; then source $loadaddr; fi; fi; run my_nand_boot;"
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_LOG=y
+CONFIG_SPL_LOG=y
+CONFIG_LOG_ERROR_RETURN=y
+CONFIG_DEFAULT_FDT_FILE="cv_kurz"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_SPL_BOOTCOUNT_LIMIT=y
+# CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR is not set
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION=y
+CONFIG_SPL_SAVEENV=y
+CONFIG_SPL_MMC_WRITE=y
+CONFIG_SPL_MTD_SUPPORT=y
+CONFIG_SPL_MUSB_NEW_SUPPORT=y
+CONFIG_SPL_OS_BOOT=y
+CONFIG_SPL_PAYLOAD="u-boot-dtb.img"
+CONFIG_SYS_PROMPT="9-pr-31 => "
+CONFIG_AUTOBOOT_KEYED=y
+CONFIG_AUTOBOOT_PROMPT="Press SPACE to abort autoboot in %d seconds\n"
+CONFIG_AUTOBOOT_DELAY_STR="d"
+CONFIG_AUTOBOOT_STOP_STR=" "
+CONFIG_CMD_SPL=y
+CONFIG_CMD_SPL_NAND_OFS=0x00A00000
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MTD=y
+CONFIG_CMD_NAND=y
+CONFIG_CMD_BTRFS=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_MTDIDS_DEFAULT="nand0=nand"
+CONFIG_MTDPARTS_DEFAULT="mtdparts=nand:128k(NAND.SPL),128k(NAND.SPL.backup1),128k(NAND.SPL.backup2),128k(NAND.SPL.backup3),1m(NAND.u-boot),128k(NAND.u-boot-env),128k(NAND.u-boot-env.backup1),8m(NAND.kernel0),8m(NAND.kernel1),256k(NAND.kparams0),256k(NAND.kparams1),128m(NAND.rootfs0),128m(NAND.rootfs1),-(NAND.data)"
+# CONFIG_ENV_IS_IN_FAT is not set
+CONFIG_ENV_IS_IN_NAND=y
+CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
+CONFIG_BOOTCOUNT_LIMIT=y
+CONFIG_DFU_TFTP=y
+CONFIG_DFU_MMC=y
+CONFIG_DFU_RAM=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_NAND=y
+# CONFIG_MMC_HW_PARTITIONING is not set
+CONFIG_MMC_OMAP_HS=y
+CONFIG_MTD=y
+CONFIG_CFI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_PHY_MSCC=y
+CONFIG_MII=y
+CONFIG_DRIVER_TI_CPSW=y
+CONFIG_SPI=y
+CONFIG_OMAP3_SPI=y
+CONFIG_USB=y
+CONFIG_USB_MUSB_HOST=y
+CONFIG_USB_MUSB_GADGET=y
+CONFIG_USB_MUSB_DSPS=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="Texas Instruments"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0451
+CONFIG_USB_GADGET_PRODUCT_NUM=0xd022
+CONFIG_USB_ETHER=y
+CONFIG_USBNET_HOST_ADDR="de:ad:be:af:00:00"
+# CONFIG_USE_TINY_PRINTF is not set
+CONFIG_OF_LIBFDT=y
diff --color -rupN uboot-2019.04/configs/cv_kurz_produktion_defconfig uboot.b/configs/cv_kurz_produktion_defconfig
--- uboot-2019.04/configs/cv_kurz_produktion_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ uboot.b/configs/cv_kurz_produktion_defconfig	2020-12-14 14:43:28.100574010 +0100
@@ -0,0 +1,82 @@
+CONFIG_ARM=y
+CONFIG_ARCH_OMAP2PLUS=y
+CONFIG_TI_COMMON_CMD_OPTIONS=y
+CONFIG_AM33XX=y
+CONFIG_CV_CLEAR_NAND_ENV=y
+CONFIG_CV_KERNEL0_OFFS=0x001c0000
+CONFIG_CV_KERNEL1_OFFS=0x009c0000
+CONFIG_CV_KPARAMS0_OFFS=0x011c0000
+CONFIG_CV_KPARAMS1_OFFS=0x01200000
+CONFIG_CV_BOOTCOUNT_LIMIT=3
+CONFIG_SPL=y
+CONFIG_DISTRO_DEFAULTS=y
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_SPL_FIT=y
+CONFIG_NAND_BOOT=y
+CONFIG_SD_BOOT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyO0,115200n8 root=/dev/mmcblk0p2 rw wait rootfstype=ext4 rootwait"
+CONFIG_BOOTCOMMAND="if mmc rescan; then if load mmc 0:1 $loadaddr /boot.scr; then source $loadaddr; fi; fi; run my_nand_boot;"
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_LOG=y
+CONFIG_SPL_LOG=y
+CONFIG_LOG_ERROR_RETURN=y
+CONFIG_DEFAULT_FDT_FILE="cv_kurz"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_SPL_BOOTCOUNT_LIMIT=y
+# CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR is not set
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION=y
+CONFIG_SPL_SAVEENV=y
+CONFIG_SPL_MMC_WRITE=y
+CONFIG_SPL_MTD_SUPPORT=y
+CONFIG_SPL_MUSB_NEW_SUPPORT=y
+CONFIG_SPL_OS_BOOT=y
+CONFIG_SPL_PAYLOAD="u-boot-dtb.img"
+CONFIG_SYS_PROMPT="9-pr-30 => "
+CONFIG_AUTOBOOT_KEYED=y
+CONFIG_AUTOBOOT_PROMPT="Press SPACE to abort autoboot in %d seconds\n"
+CONFIG_AUTOBOOT_DELAY_STR="d"
+CONFIG_AUTOBOOT_STOP_STR=" "
+CONFIG_CMD_SPL=y
+CONFIG_CMD_SPL_NAND_OFS=0x00A00000
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MTD=y
+CONFIG_CMD_NAND=y
+CONFIG_CMD_BTRFS=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_MTDIDS_DEFAULT="nand0=nand"
+CONFIG_MTDPARTS_DEFAULT="mtdparts=nand:128k(NAND.SPL),128k(NAND.SPL.backup1),128k(NAND.SPL.backup2),128k(NAND.SPL.backup3),1m(NAND.u-boot),128k(NAND.u-boot-env),128k(NAND.u-boot-env.backup1),8m(NAND.kernel0),8m(NAND.kernel1),256k(NAND.kparams0),256k(NAND.kparams1),128m(NAND.rootfs0),128m(NAND.rootfs1),-(NAND.data)"
+# CONFIG_ENV_IS_IN_FAT is not set
+CONFIG_ENV_IS_IN_NAND=y
+CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
+CONFIG_BOOTCOUNT_LIMIT=y
+CONFIG_DFU_TFTP=y
+CONFIG_DFU_MMC=y
+CONFIG_DFU_RAM=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_NAND=y
+# CONFIG_MMC_HW_PARTITIONING is not set
+CONFIG_MMC_OMAP_HS=y
+CONFIG_MTD=y
+CONFIG_CFI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_PHY_MSCC=y
+CONFIG_MII=y
+CONFIG_DRIVER_TI_CPSW=y
+CONFIG_SPI=y
+CONFIG_OMAP3_SPI=y
+CONFIG_USB=y
+CONFIG_USB_MUSB_HOST=y
+CONFIG_USB_MUSB_GADGET=y
+CONFIG_USB_MUSB_DSPS=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="Texas Instruments"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0451
+CONFIG_USB_GADGET_PRODUCT_NUM=0xd022
+CONFIG_USB_ETHER=y
+CONFIG_USBNET_HOST_ADDR="de:ad:be:af:00:00"
+# CONFIG_USE_TINY_PRINTF is not set
+CONFIG_OF_LIBFDT=y
diff --color -rupN uboot-2019.04/drivers/i2c/omap24xx_i2c.c uboot.b/drivers/i2c/omap24xx_i2c.c
--- uboot-2019.04/drivers/i2c/omap24xx_i2c.c	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/drivers/i2c/omap24xx_i2c.c	2020-12-14 08:42:25.300906673 +0100
@@ -44,6 +44,7 @@
 
 #include <asm/io.h>
 #include <asm/omap_i2c.h>
+//#include <PR.h>
 
 /*
  * Provide access to architecture-specific I2C header files for platforms
@@ -155,11 +156,13 @@ static inline const u8 *omap_i2c_get_ip_
 static inline void omap_i2c_write_reg(void __iomem *base, int ip_rev,
 				      u16 val, int reg)
 {
+//	PRE1(".\n");
 	writew(val, base + omap_i2c_get_ip_reg_map(ip_rev)[reg]);
 }
 
 static inline u16 omap_i2c_read_reg(void __iomem *base, int ip_rev, int reg)
 {
+//	PRE1(".\n");
 	return readw(base + omap_i2c_get_ip_reg_map(ip_rev)[reg]);
 }
 
diff --color -rupN uboot-2019.04/drivers/misc/i2c_eeprom.c uboot.b/drivers/misc/i2c_eeprom.c
--- uboot-2019.04/drivers/misc/i2c_eeprom.c	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/drivers/misc/i2c_eeprom.c	2020-12-14 08:42:25.668908064 +0100
@@ -9,6 +9,7 @@
 #include <i2c.h>
 #include <i2c_eeprom.h>
 
+
 int i2c_eeprom_read(struct udevice *dev, int offset, uint8_t *buf, int size)
 {
 	const struct i2c_eeprom_ops *ops = device_get_ops(dev);
diff --color -rupN uboot-2019.04/drivers/mtd/nand/raw/am335x_spl_bch.c uboot.b/drivers/mtd/nand/raw/am335x_spl_bch.c
--- uboot-2019.04/drivers/mtd/nand/raw/am335x_spl_bch.c	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/drivers/mtd/nand/raw/am335x_spl_bch.c	2020-12-14 08:42:25.460907279 +0100
@@ -14,6 +14,8 @@
 #include <asm/io.h>
 #include <linux/mtd/nand_ecc.h>
 
+#include "PR.h"
+
 static int nand_ecc_pos[] = CONFIG_SYS_NAND_ECCPOS;
 static struct mtd_info *mtd;
 static struct nand_chip nand_chip;
@@ -29,13 +31,17 @@ static struct nand_chip nand_chip;
 static int nand_command(int block, int page, uint32_t offs,
 	u8 cmd)
 {
+//	PRE1("begin\n");
 	struct nand_chip *this = mtd_to_nand(mtd);
+//	PRE1("nach mtd_to_nand\n");
 	int page_addr = page + block * CONFIG_SYS_NAND_PAGE_COUNT;
 	void (*hwctrl)(struct mtd_info *mtd, int cmd,
 			unsigned int ctrl) = this->cmd_ctrl;
 
+//	PRE1("vor busy wait ready\n");
 	while (!this->dev_ready(mtd))
 		;
+//	PRE1("nach busy wait ready\n");
 
 	/* Emulate NAND_CMD_READOOB */
 	if (cmd == NAND_CMD_READOOB) {
@@ -146,8 +152,22 @@ static int nand_is_bad_block(int block)
 	return 0;
 }
 
-static int nand_read_page(int block, int page, void *dst)
+static void preitinger_dump128(void* p) {
+#if 0
+	char* c = (char*) p;
+	printf("\n128 byte ab %lx\n", (long) p);
+
+	for (int i = 0; i < 128; ++i) {
+		printf("%x ", (int) c[i]);
+	}
+	printf("\nEnde dump\n\n");
+#endif
+}
+
+// preitinger: removed static
+/*static*/ int nand_read_page(int block, int page, void *dst, bool preitingerVerbose)
 {
+//	PRE1("begin\n");
 	struct nand_chip *this = mtd_to_nand(mtd);
 	u_char ecc_calc[ECCTOTAL];
 	u_char ecc_code[ECCTOTAL];
@@ -161,22 +181,42 @@ static int nand_read_page(int block, int
 	uint8_t *oob = &oob_data[0] + nand_ecc_pos[0];
 	uint32_t oob_pos = eccsize * eccsteps + nand_ecc_pos[0];
 
+//	PRE1("vor nand_command READ0\n");
 	nand_command(block, page, 0, NAND_CMD_READ0);
 
+//	PRE("eccsteps=%d, eccbytes=%d, eccsize=%d\n", eccsteps, eccbytes, eccsize);
+//	PRE("mtd=%lx\n", (ulong)mtd);
+//	PRE("nand_chip->IO_ADDR_R=%lx\n", (long)this->IO_ADDR_R);
+//	PRE("nand_chip->read_buf=%lx\n", (long)this->read_buf);
+//	PRE("vor for 1: this->read_buf=%x\n", (int) (this->read_buf));
+//	preitinger_dump128(this->read_buf);
+
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+//		PRE("for 1: i=%d\n", i);
 		this->ecc.hwctl(mtd, NAND_ECC_READ);
+//		if (preitingerVerbose) PRE1(".\n");
 		nand_command(block, page, data_pos, NAND_CMD_RNDOUT);
+//		if (preitingerVerbose) this->preitinger_verbose = 1;
+//		if (preitingerVerbose) PRE("vor read_buf: this->read_buf=%x\n", (int) (this->read_buf));
 
 		this->read_buf(mtd, p, eccsize);
+//		if (preitingerVerbose) PRE1("nach read_buf\n");
+		this->preitinger_verbose = 0;
 
 		nand_command(block, page, oob_pos, NAND_CMD_RNDOUT);
+//		if (preitingerVerbose) PRE1(".\n");
 
 		this->read_buf(mtd, oob, eccbytes);
+//		if (preitingerVerbose) PRE1(".\n");
 		this->ecc.calculate(mtd, p, &ecc_calc[i]);
+//		if (preitingerVerbose) PRE1(".\n");
 
 		data_pos += eccsize;
+//		if (preitingerVerbose) PRE1(".\n");
 		oob_pos += eccbytes;
+//		if (preitingerVerbose) PRE1(".\n");
 		oob += eccbytes;
+//		if (preitingerVerbose) PRE1(".\n");
 	}
 
 	/* Pick the ECC bytes out of the oob data */
@@ -184,6 +224,7 @@ static int nand_read_page(int block, int
 		ecc_code[i] = oob_data[nand_ecc_pos[i]];
 
 	eccsteps = ECCSTEPS;
+//	PRE("for 2: eccsteps=%d\n", eccsteps);
 	p = dst;
 
 	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
@@ -204,20 +245,27 @@ void nand_init(void)
 	 * Init board specific nand support
 	 */
 	mtd = nand_to_mtd(&nand_chip);
+	PRE1("mtd gesetzt!\n");
+
 	nand_chip.IO_ADDR_R = nand_chip.IO_ADDR_W =
 		(void  __iomem *)CONFIG_SYS_NAND_BASE;
+	PRE("vor board_nand_init: nand_chip->read_buf=%lx\n", (long) nand_chip.read_buf);
 	board_nand_init(&nand_chip);
+	PRE("nach board_nand_init: nand_chip->read_buf=%lx\n", (long) nand_chip.read_buf);
 
 	if (nand_chip.select_chip)
 		nand_chip.select_chip(mtd, 0);
 
 	/* NAND chip may require reset after power-on */
 	nand_command(0, 0, 0, NAND_CMD_RESET);
+
+	PRE("ende: nand_chip->read_buf=%lx\n", (long) nand_chip.read_buf);
 }
 
 /* Unselect after operation */
 void nand_deselect(void)
 {
+	PRE1("begin\n");
 	if (nand_chip.select_chip)
 		nand_chip.select_chip(mtd, -1);
 }
diff --color -rupN uboot-2019.04/drivers/mtd/nand/raw/nand_base.c uboot.b/drivers/mtd/nand/raw/nand_base.c
--- uboot-2019.04/drivers/mtd/nand/raw/nand_base.c	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/drivers/mtd/nand/raw/nand_base.c	2020-12-14 08:42:25.460907279 +0100
@@ -1,3 +1,5 @@
+#define LOG_DEBUG
+
 /*
  *  Overview:
  *   This is the generic MTD driver for NAND flash devices. It should be
@@ -45,6 +47,7 @@
 #endif
 #include <asm/io.h>
 #include <linux/errno.h>
+#include "PR.h"
 
 /* Define default oob placement schemes for large and small page devices */
 #ifdef CONFIG_SYS_NAND_DRIVER_ECC_LAYOUT
@@ -250,12 +253,19 @@ static void iowrite8_rep(void *addr, con
 	for (i = 0; i < len; i++)
 		writeb(buf[i], addr);
 }
-static void ioread8_rep(void *addr, uint8_t *buf, int len)
+static void ioread8_rep(void *addr, uint8_t *buf, int len, int verbose)
 {
 	int i;
+	uint8_t preitinger_x;
 
-	for (i = 0; i < len; i++)
-		buf[i] = readb(addr);
+	for (i = 0; i < len; i++) {
+		preitinger_x = readb(addr);
+//		if (verbose) {
+//			PRE("i=%d: x=%x, Zieladdr=%x\n", i, preitinger_x, (int)(buf+i));
+//		}
+		buf[i] = preitinger_x;
+//		if (verbose) PRE1("written\n");
+	}
 }
 
 static void ioread16_rep(void *addr, void *buf, int len)
@@ -301,9 +311,12 @@ void nand_write_buf(struct mtd_info *mtd
  */
 void nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
 {
+//	PRE("&nand_read_buf=%x, nand_read_buf=%lx, nand_read_buf16=%lx\n", (int) &nand_read_buf, (long)nand_read_buf, (long)nand_read_buf16);
 	struct nand_chip *chip = mtd_to_nand(mtd);
-
-	ioread8_rep(chip->IO_ADDR_R, buf, len);
+	if (chip->preitinger_verbose) {
+		PRE("buf=0x%x, len=0x%x\n", (int)buf, (int)len);
+	}
+	ioread8_rep(chip->IO_ADDR_R, buf, len, chip->preitinger_verbose);
 }
 
 /**
@@ -3030,6 +3043,7 @@ static int nand_onfi_get_features(struct
 /* Set default functions */
 static void nand_set_defaults(struct nand_chip *chip, int busw)
 {
+	PRE("================> nand_read_buf=0x%lx, nand_scan=0x%lx\n", (long) nand_read_buf, (long) nand_scan);
 	/* check for proper chip_delay setup, set 20us if not */
 	if (!chip->chip_delay)
 		chip->chip_delay = 20;
@@ -3077,6 +3091,8 @@ static void nand_set_defaults(struct nan
 
 	if (!chip->buf_align)
 		chip->buf_align = 1;
+
+	PRE("ende: chip->read_buf=0x%lx\n", (long) chip->read_buf);
 }
 
 /* Sanitize ONFI strings so we can safely print them */
diff --color -rupN uboot-2019.04/drivers/mtd/nand/raw/nand_spl_loaders.c uboot.b/drivers/mtd/nand/raw/nand_spl_loaders.c
--- uboot-2019.04/drivers/mtd/nand/raw/nand_spl_loaders.c	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/drivers/mtd/nand/raw/nand_spl_loaders.c	2020-12-14 08:42:25.464907293 +0100
@@ -3,6 +3,9 @@ int nand_spl_load_image(uint32_t offs, u
 	unsigned int block, lastblock;
 	unsigned int page, page_offset;
 
+//	PRE("3> offs=%x, size=%x, dst=%x\n", offs, size, (int) dst);
+//	PRE("CONFIG_SYS_NAND_PAGE_COUNT=%d\n", CONFIG_SYS_NAND_PAGE_COUNT);
+
 	/* offs has to be aligned to a page address! */
 	block = offs / CONFIG_SYS_NAND_BLOCK_SIZE;
 	lastblock = (offs + size - 1) / CONFIG_SYS_NAND_BLOCK_SIZE;
@@ -10,10 +13,16 @@ int nand_spl_load_image(uint32_t offs, u
 	page_offset = offs % CONFIG_SYS_NAND_PAGE_SIZE;
 
 	while (block <= lastblock) {
+//		PRE("w1: block=%d, lastblock=%d\n", block, lastblock);
+#ifndef CONFIG_SPL_BUILD
 		if (!nand_is_bad_block(block)) {
+#endif
+//			PRE1("! bad block\n");
 			/* Skip bad blocks */
 			while (page < CONFIG_SYS_NAND_PAGE_COUNT) {
-				nand_read_page(block, page, dst);
+//				PRE("w2: page=%d\n", page);
+				nand_read_page(block, page, dst, (size == 0x4d0f1a));
+//				PRE1("w2: nach nand_read_page\n");
 				/*
 				 * When offs is not aligned to page address the
 				 * extra offset is copied to dst as well. Copy
@@ -31,13 +40,17 @@ int nand_spl_load_image(uint32_t offs, u
 			}
 
 			page = 0;
+#ifndef CONFIG_SPL_BUILD
 		} else {
 			lastblock++;
+			PRE("skipped badblock; now lastblock=%d\n", lastblock);
 		}
+#endif
 
 		block++;
 	}
 
+//	PRE1("end\n");
 	return 0;
 }
 
diff --color -rupN uboot-2019.04/drivers/mtd/nand/raw/nand_spl_simple.c uboot.b/drivers/mtd/nand/raw/nand_spl_simple.c
--- uboot-2019.04/drivers/mtd/nand/raw/nand_spl_simple.c	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/drivers/mtd/nand/raw/nand_spl_simple.c	2020-12-14 08:42:25.464907293 +0100
@@ -116,6 +116,7 @@ static int nand_is_bad_block(int block)
 	struct nand_chip *this = mtd_to_nand(mtd);
 	u_char bb_data[2];
 
+	PRE1("vor nand_command\n");
 	nand_command(block, 0, CONFIG_SYS_NAND_BAD_BLOCK_POS,
 		NAND_CMD_READOOB);
 
@@ -123,11 +124,15 @@ static int nand_is_bad_block(int block)
 	 * Read one byte (or two if it's a 16 bit chip).
 	 */
 	if (this->options & NAND_BUSWIDTH_16) {
+		PRE1("NAND_BUSWIDTH_16?!\n");
+
 		this->read_buf(mtd, bb_data, 2);
 		if (bb_data[0] != 0xff || bb_data[1] != 0xff)
 			return 1;
 	} else {
+		PRE1("!NAND_BUSWIDTH_16 - PUH!\n");
 		this->read_buf(mtd, bb_data, 1);
+		PRE1("nach read_buf\n");
 		if (bb_data[0] != 0xff)
 			return 1;
 	}
@@ -215,6 +220,7 @@ void nand_init(void)
 	 * Init board specific nand support
 	 */
 	mtd = nand_to_mtd(&nand_chip);
+	PRE1("nand_spl_simple:nand_init\n");
 	nand_chip.IO_ADDR_R = nand_chip.IO_ADDR_W =
 		(void  __iomem *)CONFIG_SYS_NAND_BASE;
 	board_nand_init(&nand_chip);
diff --color -rupN uboot-2019.04/drivers/mtd/nand/raw/omap_gpmc.c uboot.b/drivers/mtd/nand/raw/omap_gpmc.c
--- uboot-2019.04/drivers/mtd/nand/raw/omap_gpmc.c	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/drivers/mtd/nand/raw/omap_gpmc.c	2020-12-14 08:42:25.420907128 +0100
@@ -15,6 +15,8 @@
 #include <nand.h>
 #include <linux/mtd/omap_elm.h>
 
+#include "PR.h"
+
 #define BADBLOCK_MARKER_LENGTH	2
 #define SECTOR_BYTES		512
 #define ECCCLEAR		(0x1 << 8)
@@ -399,18 +401,26 @@ static int __read_prefetch_aligned(struc
 		return ret;
 
 	do {
+		if (chip->preitinger_verbose) PRE(". len=%d\n", len);
 		int i;
 
 		cnt = readl(&gpmc_cfg->prefetch_status);
+		if (chip->preitinger_verbose) PRE("prefetch_status: %u\n", cnt);
 		cnt = PREFETCH_STATUS_FIFO_CNT(cnt);
+		if (chip->preitinger_verbose) PRE("cnt: %u\n", cnt);
 
 		for (i = 0; i < cnt / 4; i++) {
+			if (chip->preitinger_verbose) PRE("CONFIG_SYS_NAND_BASE=%x\n", (int) CONFIG_SYS_NAND_BASE);
 			*buf++ = readl(CONFIG_SYS_NAND_BASE);
+			if (chip->preitinger_verbose) PRE("nach readl: Position %x; Wert %x\n", (int)buf, *(buf-1));
 			len -= 4;
 		}
+		if (chip->preitinger_verbose) PRE1("nach for\n");
 	} while (len);
 
+	if (chip->preitinger_verbose) PRE1("vor omap_prefetch_reset\n");
 	omap_prefetch_reset();
+	if (chip->preitinger_verbose) PRE1("nach omap_prefetch_reset\n");
 
 	return 0;
 }
@@ -427,6 +437,7 @@ static inline void omap_nand_read(struct
 
 static void omap_nand_read_prefetch(struct mtd_info *mtd, uint8_t *buf, int len)
 {
+//	PRE1("ha!\n");
 	int ret;
 	uint32_t head, tail;
 	struct nand_chip *chip = mtd_to_nand(mtd);
@@ -436,7 +447,12 @@ static void omap_nand_read_prefetch(stru
 	 * the overlap byte-wise.
 	 */
 	head = ((uint32_t) buf) % 4;
+	if (chip->preitinger_verbose) PRE("head=%d\n", head);
 	if (head) {
+		// preitinger: FIX BEGIN
+		head = 4 - head;
+		// preitinger: FIX END
+
 		omap_nand_read(mtd, buf, head);
 		buf += head;
 		len -= head;
@@ -447,6 +463,7 @@ static void omap_nand_read_prefetch(stru
 	 * If there's a residue, care for it byte-wise afterwards.
 	 */
 	tail = len % 4;
+	if (chip->preitinger_verbose) PRE("tail=%d\n", tail);
 
 	ret = __read_prefetch_aligned(chip, (uint32_t *)buf, len - tail);
 	if (ret < 0) {
@@ -961,6 +978,8 @@ int __maybe_unused omap_nand_switch_ecc(
  */
 int board_nand_init(struct nand_chip *nand)
 {
+//	PRE1("omap_gpmc\n");
+	nand->preitinger_verbose = false;
 	int32_t gpmc_config = 0;
 	int cs = cs_next++;
 	int err = 0;
diff --color -rupN uboot-2019.04/drivers/watchdog/omap_wdt.c uboot.b/drivers/watchdog/omap_wdt.c
--- uboot-2019.04/drivers/watchdog/omap_wdt.c	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/drivers/watchdog/omap_wdt.c	2020-12-14 08:42:24.712904451 +0100
@@ -43,6 +43,8 @@
 #include <asm/processor.h>
 #include <asm/arch/cpu.h>
 
+#include "PR.h"
+
 /* Hardware timeout in seconds */
 #define WDT_HW_TIMEOUT 60
 
@@ -51,7 +53,19 @@ static unsigned int wdt_trgr_pattern = 0
 void hw_watchdog_reset(void)
 {
 	struct wd_timer *wdt = (struct wd_timer *)WDT_BASE;
+	static int preitingerCount = 0;
+
+	if (preitingerCount > 0) {
+		// preitinger: HACK! nur einmal resetten, danach soll reboot erfolgen nach 60s wenn nicht erfolgreich gebootet!
+		return;
+	}
 
+	if (preitingerCount++ % 10 == 0) {
+		PRE("preitingerCount=%d\n", preitingerCount);
+	}
+
+
+//	PRE1("hier\n");
 	/*
 	 * Somebody just triggered watchdog reset and write to WTGR register
 	 * is in progress. It is resetting right now, no need to trigger it
@@ -76,6 +90,8 @@ void hw_watchdog_reset(void)
 static int omap_wdt_set_timeout(unsigned int timeout)
 {
 	struct wd_timer *wdt = (struct wd_timer *)WDT_BASE;
+
+	PRE("timeout=%u\n", timeout);
 	u32 pre_margin = GET_WLDR_VAL(timeout);
 
 	/* just count up at 32 KHz */
@@ -93,6 +109,7 @@ void hw_watchdog_disable(void)
 {
 	struct wd_timer *wdt = (struct wd_timer *)WDT_BASE;
 
+	PRE1("\n\n\n\t**************************************     Oje disabled!! :-(     *********************\n\n\n");
 	/*
 	 * Disable watchdog
 	 */
@@ -107,6 +124,7 @@ void hw_watchdog_disable(void)
 void hw_watchdog_init(void)
 {
 	struct wd_timer *wdt = (struct wd_timer *)WDT_BASE;
+	PRE1("hw watchdog init\n");
 
 	/*
 	 * Make sure the watchdog is disabled. This is unfortunately required
diff --color -rupN uboot-2019.04/env/common.c uboot.b/env/common.c
--- uboot-2019.04/env/common.c	2020-12-14 14:53:34.622386847 +0100
+++ uboot.b/env/common.c	2020-12-14 08:42:27.440914755 +0100
@@ -15,6 +15,8 @@
 #include <errno.h>
 #include <malloc.h>
 
+#include "PR.h"
+
 DECLARE_GLOBAL_DATA_PTR;
 
 /************************************************************************
@@ -33,6 +35,15 @@ struct hsearch_data env_htab = {
 int env_get_yesno(const char *var)
 {
 	char *s = env_get(var);
+	if (var) {
+		PRE("preitinger: env_get_yesno: var=%s\n", var);
+	} else {
+		PRE1("preitinger: env_get_yesno: var=null\n");
+	}
+	PRE("preitinger: env_get_yesno: s=%d\n", (int)s);
+	if (s) {
+		PRE("s: '%s'\n", s);
+	}
 
 	if (s == NULL)
 		return -1;
diff --color -rupN uboot-2019.04/env/env.c uboot.b/env/env.c
--- uboot-2019.04/env/env.c	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/env/env.c	2020-12-14 08:42:27.440914755 +0100
@@ -7,6 +7,8 @@
 #include <common.h>
 #include <environment.h>
 
+#include "PR.h"
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #if defined(CONFIG_NEEDS_MANUAL_RELOC)
@@ -151,8 +153,10 @@ static struct env_driver *env_driver_loo
 	if (loc == ENVL_UNKNOWN)
 		return NULL;
 
+	PRE("loc=%d\n", (int)loc);
 	drv = _env_driver_lookup(loc);
 	if (!drv) {
+		PRE("no env driver for location %d\n", (int)loc);
 		debug("%s: No environment driver for location %d\n", __func__,
 		      loc);
 		return NULL;
@@ -168,6 +172,7 @@ __weak int env_get_char_spec(int index)
 
 int env_get_char(int index)
 {
+//	printf("preitinger: env_get_char: gd->env_valid=%d\n", (int) gd->env_valid);
 	if (gd->env_valid == ENV_INVALID)
 		return default_environment[index];
 	else
@@ -181,6 +186,7 @@ int env_load(void)
 	int prio;
 
 	for (prio = 0; (drv = env_driver_lookup(ENVOP_LOAD, prio)); prio++) {
+		PRE("prio=%d\n", prio);
 		int ret;
 
 		if (!drv->load)
@@ -195,6 +201,7 @@ int env_load(void)
 		 * drv->load() in some underlying API, and it must be exactly
 		 * one message.
 		 */
+		PRE1("vor drv->load()\n");
 		ret = drv->load();
 		if (!ret) {
 			printf("OK\n");
@@ -231,9 +238,11 @@ int env_save(void)
 	struct env_driver *drv;
 
 	drv = env_driver_lookup(ENVOP_SAVE, gd->env_load_prio);
+	PRE("drv=%p\n", drv);
 	if (drv) {
 		int ret;
 
+		PRE("drv->save: %p\n", drv->save);
 		if (!drv->save)
 			return -ENODEV;
 
@@ -260,10 +269,13 @@ int env_init(void)
 	int ret = -ENOENT;
 	int prio;
 
+	PRE1("env_init\n");
+
 	for (prio = 0; (drv = env_driver_lookup(ENVOP_INIT, prio)); prio++) {
 		if (!drv->init || !(ret = drv->init()))
 			env_set_inited(drv->location);
 
+
 		debug("%s: Environment %s init done (ret=%d)\n", __func__,
 		      drv->name, ret);
 	}
diff --color -rupN uboot-2019.04/include/common.h uboot.b/include/common.h
--- uboot-2019.04/include/common.h	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/include/common.h	2020-12-14 08:42:11.652854870 +0100
@@ -7,6 +7,7 @@
 #ifndef __COMMON_H_
 #define __COMMON_H_	1
 
+
 #ifndef __ASSEMBLY__		/* put C only stuff in this section */
 
 typedef unsigned char		uchar;
@@ -34,6 +35,7 @@ typedef volatile unsigned char	vu_char;
 #include <flash.h>
 #include <image.h>
 
+
 #ifdef __LP64__
 #define CONFIG_SYS_SUPPORT_64BIT_DATA
 #endif
diff --color -rupN uboot-2019.04/include/configs/am335x_evm.h uboot.b/include/configs/am335x_evm.h
--- uboot-2019.04/include/configs/am335x_evm.h	2020-12-14 14:53:34.622386847 +0100
+++ uboot.b/include/configs/am335x_evm.h	2020-12-14 08:42:11.668854930 +0100
@@ -288,12 +288,18 @@
 #define CONFIG_SYS_NAND_ECCBYTES	14
 #define CONFIG_SYS_NAND_ONFI_DETECTION
 #define CONFIG_NAND_OMAP_ECCSCHEME	OMAP_ECC_BCH8_CODE_HW
-#define CONFIG_SYS_NAND_U_BOOT_OFFS	0x000c0000
+
+// BEGIN generated by Java Tool yocto/tools/MtdParts
+#define CONFIG_SYS_NAND_U_BOOT_OFFS 0x00080000
+// END generated by Java Tool yocto/tools/MtdParts
+
 /* NAND: SPL related configs */
 #ifdef CONFIG_SPL_OS_BOOT
-#define CONFIG_SYS_NAND_SPL_KERNEL_OFFS	0x00200000 /* kernel offset */
+// alt: #define CONFIG_SYS_NAND_SPL_KERNEL_OFFS	0x00200000 /* kernel offset */
+//#define CONFIG_SYS_NAND_SPL_KERNEL0_OFFS 0x001c0000
+//#define CONFIG_SYS_NAND_SPL_KERNEL1_OFFS 0x009c0000
 #endif
-#endif /* !CONFIG_NAND */
+#endif /* CONFIG_NAND */
 
 /*
  * For NOR boot, we must set this to the start of where NOR is mapped
@@ -366,8 +372,13 @@
 #define CONFIG_ENV_OFFSET		(512 << 10)	/* 512 KiB */
 #define CONFIG_ENV_OFFSET_REDUND	(768 << 10)	/* 768 KiB */
 #elif defined(CONFIG_ENV_IS_IN_NAND)
-#define CONFIG_ENV_OFFSET		0x001c0000
-#define CONFIG_ENV_OFFSET_REDUND	0x001e0000
+
+
+// BEGIN generated by Java Tool yocto/tools/MtdParts
+#define CONFIG_ENV_OFFSET		0x00180000
+#define CONFIG_ENV_OFFSET_REDUND	0x001a0000
+// END generated by Java Tool yocto/tools/MtdParts
+
 #define CONFIG_SYS_ENV_SECT_SIZE	CONFIG_SYS_NAND_BLOCK_SIZE
 #endif
 
@@ -404,4 +415,7 @@
 #define CLK_SYNTHESIZER_I2C_ADDR 0x65
 #endif
 
+//#define CONFIG_ENV_OFFSET 0x10
+//#define CONFIG_SYS_DEF_EEPROM_ADDR 0x10
+
 #endif	/* ! __CONFIG_AM335X_EVM_H */
diff --color -rupN uboot-2019.04/include/linux/mtd/rawnand.h uboot.b/include/linux/mtd/rawnand.h
--- uboot-2019.04/include/linux/mtd/rawnand.h	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/include/linux/mtd/rawnand.h	2020-12-14 08:42:12.000856196 +0100
@@ -959,6 +959,7 @@ struct nand_chip {
 	struct nand_bbt_descr *badblock_pattern;
 
 	void *priv;
+	bool preitinger_verbose;
 };
 
 static inline struct nand_chip *mtd_to_nand(struct mtd_info *mtd)
diff --color -rupN uboot-2019.04/include/PR.h uboot.b/include/PR.h
--- uboot-2019.04/include/PR.h	1970-01-01 01:00:00.000000000 +0100
+++ uboot.b/include/PR.h	2020-12-14 08:42:13.092860357 +0100
@@ -0,0 +1,23 @@
+/*
+ * PR.h
+ *
+ *  Created on: Jul 16, 2019
+ *      Author: preitinger
+ */
+
+#ifndef INCLUDE_PR_H_
+#define INCLUDE_PR_H_
+
+
+// preitinger abk fuer debugging
+#if 1
+#define PRE1(x) printf("preitinger(1): %s:%s() - " x, __FILE__, __func__)
+#define PRE(x, ...) printf("preitinger(1): %s:%s() - " x, __FILE__, __func__, __VA_ARGS__)
+#else
+#define PRE1(x)
+#define PRE(x, ...)
+#endif
+
+
+
+#endif /* INCLUDE_PR_H_ */
diff --color -rupN uboot-2019.04/tools/env/embedded.c uboot.b/tools/env/embedded.c
--- uboot-2019.04/tools/env/embedded.c	1970-01-01 01:00:00.000000000 +0100
+++ uboot.b/tools/env/embedded.c	2020-12-14 08:41:59.668809003 +0100
@@ -0,0 +1 @@
+#include <../env/embedded.c>
diff --color -rupN uboot-2019.04/tools/env/fw_env.config uboot.b/tools/env/fw_env.config
--- uboot-2019.04/tools/env/fw_env.config	2019-04-09 03:40:40.000000000 +0200
+++ uboot.b/tools/env/fw_env.config	2020-12-14 08:41:59.668809003 +0100
@@ -8,8 +8,8 @@
 
 # NOR example
 # MTD device name	Device offset	Env. size	Flash sector size	Number of sectors
-/dev/mtd1		0x0000		0x4000		0x4000
-/dev/mtd2		0x0000		0x4000		0x4000
+/dev/mtd6		0x0000		0x20000		0x20000
+/dev/mtd7		0x0000		0x20000		0x20000
 
 # MTD SPI-dataflash example
 # MTD device name	Device offset	Env. size	Flash sector size	Number of sectors
